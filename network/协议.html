<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>协议 | Mavericker&#39;s Blog</title>
    <meta name="description" content="赵佐骑的个人博客，前端">
    <link rel="icon" href="/fav.ico">
  <script type="text/javascript">var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "https://hm.baidu.com/hm.js?5a982c6c5e0d0d786523e60a7a647022";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script>
    
    <link rel="preload" href="/assets/css/0.styles.76307617.css" as="style"><link rel="preload" href="/assets/js/app.813c17b6.js" as="script"><link rel="preload" href="/assets/js/40.92805123.js" as="script"><link rel="prefetch" href="/assets/js/12.e71bc87f.js"><link rel="prefetch" href="/assets/js/2.b8909fec.js"><link rel="prefetch" href="/assets/js/3.8d04fbbf.js"><link rel="prefetch" href="/assets/js/4.76cb4dbf.js"><link rel="prefetch" href="/assets/js/5.82846fcf.js"><link rel="prefetch" href="/assets/js/6.d026f6bc.js"><link rel="prefetch" href="/assets/js/7.614c0c26.js"><link rel="prefetch" href="/assets/js/8.91f64669.js"><link rel="prefetch" href="/assets/js/9.bd03efb0.js"><link rel="prefetch" href="/assets/js/10.b72941af.js"><link rel="prefetch" href="/assets/js/11.55c4af94.js"><link rel="prefetch" href="/assets/js/13.1b4e26a1.js"><link rel="prefetch" href="/assets/js/14.6ce88fa2.js"><link rel="prefetch" href="/assets/js/15.53815097.js"><link rel="prefetch" href="/assets/js/16.3d021803.js"><link rel="prefetch" href="/assets/js/17.ac6b335f.js"><link rel="prefetch" href="/assets/js/18.539a72e1.js"><link rel="prefetch" href="/assets/js/19.46c5d299.js"><link rel="prefetch" href="/assets/js/20.bbe25a47.js"><link rel="prefetch" href="/assets/js/21.b57b41b7.js"><link rel="prefetch" href="/assets/js/22.24104113.js"><link rel="prefetch" href="/assets/js/23.a1aadb14.js"><link rel="prefetch" href="/assets/js/24.7f66a479.js"><link rel="prefetch" href="/assets/js/25.0d998f42.js"><link rel="prefetch" href="/assets/js/26.0448ab80.js"><link rel="prefetch" href="/assets/js/27.20ca2d83.js"><link rel="prefetch" href="/assets/js/28.56900e6e.js"><link rel="prefetch" href="/assets/js/29.580fb71b.js"><link rel="prefetch" href="/assets/js/30.9b752411.js"><link rel="prefetch" href="/assets/js/31.71a3e01f.js"><link rel="prefetch" href="/assets/js/32.633b1158.js"><link rel="prefetch" href="/assets/js/33.f80c8c22.js"><link rel="prefetch" href="/assets/js/34.f4d2a30d.js"><link rel="prefetch" href="/assets/js/35.3ad15739.js"><link rel="prefetch" href="/assets/js/36.324804a5.js"><link rel="prefetch" href="/assets/js/37.59925d68.js"><link rel="prefetch" href="/assets/js/38.e6f8d299.js"><link rel="prefetch" href="/assets/js/39.46060081.js"><link rel="prefetch" href="/assets/js/41.8516a958.js"><link rel="prefetch" href="/assets/js/42.985e6416.js"><link rel="prefetch" href="/assets/js/43.770aaa1a.js"><link rel="prefetch" href="/assets/js/44.56039045.js"><link rel="prefetch" href="/assets/js/45.07330c76.js"><link rel="prefetch" href="/assets/js/46.6d200ff4.js"><link rel="prefetch" href="/assets/js/47.2ecec06c.js"><link rel="prefetch" href="/assets/js/48.2a749d70.js"><link rel="prefetch" href="/assets/js/49.5defabfe.js"><link rel="prefetch" href="/assets/js/50.391c2931.js"><link rel="prefetch" href="/assets/js/51.823ddd3e.js"><link rel="prefetch" href="/assets/js/52.272e9779.js"><link rel="prefetch" href="/assets/js/53.dd41478f.js"><link rel="prefetch" href="/assets/js/54.bdd75c33.js"><link rel="prefetch" href="/assets/js/55.6713f330.js"><link rel="prefetch" href="/assets/js/56.19a9b3e2.js"><link rel="prefetch" href="/assets/js/57.30130f5c.js"><link rel="prefetch" href="/assets/js/58.63ce249b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.76307617.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Mavericker's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/network/" class="nav-link router-link-active">网络</a></div><div class="nav-item"><a href="/css/" class="nav-link">CSS</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/javascript/basic/" class="nav-link">JavaScript基础</a></li><li class="dropdown-item"><!----> <a href="/javascript/pro/" class="nav-link">JavaScript专题</a></li></ul></div></div><div class="nav-item"><a href="/vue/" class="nav-link">Vue</a></div><div class="nav-item"><a href="/react/" class="nav-link">React</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/article/" class="nav-link">文章</a></div><div class="nav-item"><a href="/resume/" class="nav-link">个人简历</a></div><div class="nav-item"><a href="https://github.com/Mavericker-1996/Mavericker-1996.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/network/" class="nav-link router-link-active">网络</a></div><div class="nav-item"><a href="/css/" class="nav-link">CSS</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/javascript/basic/" class="nav-link">JavaScript基础</a></li><li class="dropdown-item"><!----> <a href="/javascript/pro/" class="nav-link">JavaScript专题</a></li></ul></div></div><div class="nav-item"><a href="/vue/" class="nav-link">Vue</a></div><div class="nav-item"><a href="/react/" class="nav-link">React</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/article/" class="nav-link">文章</a></div><div class="nav-item"><a href="/resume/" class="nav-link">个人简历</a></div><div class="nav-item"><a href="https://github.com/Mavericker-1996/Mavericker-1996.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/network/" class="sidebar-link">写在前面的话</a></li><li><a href="/network/从输入URL到页面加载说起.html" class="sidebar-link">从输入URL到页面加载说起</a></li><li><a href="/network/协议.html" class="active sidebar-link">协议</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/network/协议.html#协议分层" class="sidebar-link">协议分层</a></li><li class="sidebar-sub-header"><a href="/network/协议.html#dns协议" class="sidebar-link">DNS协议</a></li><li class="sidebar-sub-header"><a href="/network/协议.html#负载均衡" class="sidebar-link">负载均衡</a></li><li class="sidebar-sub-header"><a href="/network/协议.html#http协议" class="sidebar-link">HTTP协议</a></li><li class="sidebar-sub-header"><a href="/network/协议.html#tcp和udp" class="sidebar-link">TCP和UDP</a></li></ul></li><li><a href="/network/HTTP缓存机制.html" class="sidebar-link">HTTP缓存机制</a></li><li><a href="/network/存储.html" class="sidebar-link">存储</a></li><li><a href="/network/ajax.html" class="sidebar-link">AJAX</a></li><li><a href="/network/ajax跨域.html" class="sidebar-link">ajax跨域</a></li><li><a href="/network/安全.html" class="sidebar-link">安全</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="协议"><a href="#协议" aria-hidden="true" class="header-anchor">#</a> 协议</h1> <h2 id="协议分层"><a href="#协议分层" aria-hidden="true" class="header-anchor">#</a> 协议分层</h2> <h3 id="五层因特网协议栈"><a href="#五层因特网协议栈" aria-hidden="true" class="header-anchor">#</a> 五层因特网协议栈</h3> <p>1.<strong>应用层</strong>(dns,http) DNS解析成IP并发送http请求</p> <p>2.<strong>传输层</strong>(tcp,udp) 建立tcp连接（三次握手）</p> <p>3.<strong>网络层</strong>(IP,ARP) IP寻址</p> <p>4.<strong>数据链路层</strong>(PPP) 封装成帧</p> <p>5.<strong>物理层</strong>(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）</p> <p>简要概括就是：</p> <blockquote><p>从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。</p></blockquote> <h3 id="七层osi框架"><a href="#七层osi框架" aria-hidden="true" class="header-anchor">#</a> 七层OSI框架</h3> <p>在五层的应用层和传输层之间增加了表示层和会话层。</p> <p><strong>表示层</strong> 主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等</p> <p><strong>会话层</strong> 它具体管理不同用户和进程之间的对话，如控制登陆和注销过程</p> <h2 id="dns协议"><a href="#dns协议" aria-hidden="true" class="header-anchor">#</a> DNS协议</h2> <h3 id="dns查找"><a href="#dns查找" aria-hidden="true" class="header-anchor">#</a> <a href="https://www.cnblogs.com/xsilence/p/6035559.html" target="_blank" rel="noopener noreferrer">DNS查找<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3> <p>浏览器DNS查找顺序一般是这样的：浏览器缓存→系统缓存→路由器缓存→ISP DNS 缓存→递归搜索。</p> <h4 id="详细过程如下："><a href="#详细过程如下：" aria-hidden="true" class="header-anchor">#</a> 详细过程如下：</h4> <h4 id="a-浏览器缓存，浏览器会缓存dns记录一段时间。"><a href="#a-浏览器缓存，浏览器会缓存dns记录一段时间。" aria-hidden="true" class="header-anchor">#</a> a. 浏览器缓存，浏览器会缓存DNS记录一段时间。</h4> <p>​        操作系统没有设定浏览器存储DNS记录的时间长短，不同的浏览器会存储各自的一个固定时间，时长为2~30分钟不等。</p> <h4 id="b-系统缓存"><a href="#b-系统缓存" aria-hidden="true" class="header-anchor">#</a> b. 系统缓存</h4> <p>​        如果浏览器缓存里没有找到需要的记录，浏览器会做一个操作系统调用（windows里是gethostname），这样子，就可以获得系统缓存里的记录啦。</p> <h4 id="c-路由器缓存"><a href="#c-路由器缓存" aria-hidden="true" class="header-anchor">#</a> c. 路由器缓存</h4> <p>​        接下来，如果还是没有找到需要的缓存，将前面的查询请求发给路由器，它一般会有自己的DNS缓存。</p> <h4 id="d-如果还是没有，那么就去检查isp有没有吧"><a href="#d-如果还是没有，那么就去检查isp有没有吧" aria-hidden="true" class="header-anchor">#</a> d. 如果还是没有，那么就去检查ISP有没有吧~</h4> <p>​        每一个ISP（网络服务提供商），或一个大学，甚至是一个大学里的系都会有一个自己的本地域名服务器，他会在url第一次访问时缓存该域名的指向。下次再访问时，他会从缓存里把这个url曾经指向的IP调出来。</p> <h4 id="e-递归搜索"><a href="#e-递归搜索" aria-hidden="true" class="header-anchor">#</a> e. 递归搜索</h4> <p>​        还是没有需要的缓存~ 就只能放大招啦~
你的ISP的DNS服务器会从根域名开始进行递归查询。</p> <h5 id="递归查询："><a href="#递归查询：" aria-hidden="true" class="header-anchor">#</a> <strong>递归查询</strong>：</h5> <p>​        主机向本地域名服务器的查询一般都是采用<strong>递归查询</strong>。</p> <p>​        如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其根域名服务器继续发出查询请求报文(即替主机继续查询)，接着根域名服务器访问顶级域服务器，接着权威DNS服务器，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是返回一个失败的响应，表示无法查询到所需的IP地址。</p> <h5 id="迭代查询："><a href="#迭代查询：" aria-hidden="true" class="header-anchor">#</a> <strong>迭代查询</strong>：</h5> <p>​        本地域名服务器向根域名服务器的查询通常是采用<strong>迭代查询</strong>。</p> <p>​        当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么返回给本地域名服务器所要查询的IP地址，要么返回给本地域名服务器下一步应当查询的域名服务器的IP地址。</p> <h2 id="负载均衡"><a href="#负载均衡" aria-hidden="true" class="header-anchor">#</a> 负载均衡</h2> <p>对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合<u>反向代理</u>实现负载均衡。</p> <h4 id="正向代理与反向代理"><a href="#正向代理与反向代理" aria-hidden="true" class="header-anchor">#</a> <a href="https://www.cnblogs.com/Anker/p/6056540.html" target="_blank" rel="noopener noreferrer">正向代理与反向代理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h4> <ol><li><p><strong>正向代理</strong></p> <h6 id="正向代理类似一个跳板机，代理访问外部资源。"><a href="#正向代理类似一个跳板机，代理访问外部资源。" aria-hidden="true" class="header-anchor">#</a> 正向代理类似一个跳板机，代理访问外部资源。</h6> <p><img src="http://mavericker.oss-cn-beijing.aliyuncs.com/18-12-24/10680180.jpg" alt></p> <p>举个例子：</p> <p>我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代理服务器呢,他能访问那个我不能访问的网站，于是我先连上代理服务器,告诉他我需要那个无法访问网站的内容，代理服务器去取回来,然后返回给我。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。</p> <p><strong>客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。</strong></p> <p>总结来说：正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。</p></li> <li><p><strong>反向代理</strong></p> <p>初次接触方向代理的感觉是，客户端是无感知代理的存在的，反向代理对外都是透明的，访问者者并不知道自己访问的是一个代理。因为客户端<u>不需要任何配置</u>就可以访问。</p> <p>反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p> <p>反向代理的作用</p> <ul><li><p>保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击</p> <p>大型网站，通常将反向代理作为公网访问地址，Web服务器是内网。</p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180813/JBE751djLB.png?imageslim" alt="mark"></p></li> <li><p>负载均衡，通过反向代理服务器来优化网站的负载</p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180813/fD4kkKKc52.png?imageslim" alt="mark"></p></li></ul></li> <li><p><strong>两者区别</strong></p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180813/431EID4C9h.png?imageslim" alt="mark"></p></li> <li><p><strong>正向代理与反向代理通俗理解</strong></p> <p>可以参考这个<a href="https://blog.csdn.net/zhanghanboke/article/details/77488894" target="_blank" rel="noopener noreferrer">网站<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li></ol> <h2 id="http协议"><a href="#http协议" aria-hidden="true" class="header-anchor">#</a> HTTP协议</h2> <h3 id="http报文格式"><a href="#http报文格式" aria-hidden="true" class="header-anchor">#</a> HTTP报文格式</h3> <h4 id="请求报文"><a href="#请求报文" aria-hidden="true" class="header-anchor">#</a> 请求报文</h4> <p>一个HTTP请求报文由请求行（request line）、请求头（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。 回车符换行符即<code>\r</code> <code>\n</code></p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180811/kl4mjCB578.png?imageslim" alt="mark"></p> <ol><li><p><strong>请求行</strong></p> <p>请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如，</p> <p><code>GET /index.html HTTP/1.1</code></p> <p>根据HTTP标准，HTTP请求可以使用多种请求方法。 HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180813/GDcECEI2ca.png?imageslim" alt="mark"></p></li> <li><p><strong>请求头</strong></p> <p>常用的请求头部：</p> <ul><li>Accept：接受类型，表示浏览器支持的MIMIE类型</li> <li>Accept-Encoding：浏览器支持的压缩类型，如gzip等。超出类型不能接受</li> <li>Content-Type：客户端发送出去实体内容的类型</li> <li>Cahe-Control：指定请求和响应遵循的缓存机制，如no-cache</li> <li>If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中</li> <li>Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间</li> <li>Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中</li> <li>If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中</li> <li>Cookie: 有cookie并且<strong>同域访问</strong>时会自动带上</li> <li>Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive</li> <li>Host：请求的服务器URL</li> <li>Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私</li> <li>Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)</li> <li>User-Agent：用户客户端的一些必要信息，如UA头部等</li></ul></li> <li><p><strong>GET和POST请求</strong></p> <ul><li><p>GET</p> <p>使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号<code>?</code>代表URL的结尾与请求参数的开始，各个参数之间<code>&amp;</code>符号隔开传递参数长度受限制。 显然，这种方式不适合传送<u>私密数据</u>。另外，由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别1024个字符，<u>所以如果需要传送大量数据的时候，也不适合使用GET方式</u>。</p> <p>常见的GET报文</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>GET /search?hl=zh-CN&amp;source=hp&amp;q=domety&amp;aq=f&amp;oq= HTTP/1.1  
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, 
application/msword, application/x-silverlight, application/x-shockwave-flash, */*  
Referer: &lt;a href=&quot;http://www.google.cn/&quot;&gt;http://www.google.cn/&lt;/a&gt;  
Accept-Language: zh-cn  
Accept-Encoding: gzip, deflate  
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  
Host: &lt;a href=&quot;http://www.google.cn&quot;&gt;www.google.cn&lt;/a&gt;  
Connection: Keep-Alive  
Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; 
NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-
FxlRugatx63JLv7CWMD6UB_O_r 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></li> <li><p>POST</p> <p>对于上面提到的不适合使用GET方式的情况，可以考虑使用POST方式，因为使用POST方法可以允许客户端给服务器提供信息较多。POST方法将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。还以上面的搜索domety为例，如果使用POST方式的话，报文如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>POST /search HTTP/1.1  
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, 
application/msword, application/x-silverlight, application/x-shockwave-flash, */*  
Referer: &lt;a href=&quot;http://www.google.cn/&quot;&gt;http://www.google.cn/&lt;/a&gt;  
Accept-Language: zh-cn  
Accept-Encoding: gzip, deflate  
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  
Host: &lt;a href=&quot;http://www.google.cn&quot;&gt;www.google.cn&lt;/a&gt;  
Connection: Keep-Alive  
Cookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; 
NID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-
FxlRugatx63JLv7CWMD6UB_O_r  
 
hl=zh-CN&amp;source=hp&amp;q=domety
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div></li> <li><p>HEAD</p> <p>HEAD就像GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。</p></li> <li><p>GET和POST区别</p> <p>可参考这个<a href="https://www.cnblogs.com/longm/p/7205318.html?utm_source=itdadao&utm_medium=referral" target="_blank" rel="noopener noreferrer">链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li></ul></li></ol> <h4 id="响应报文"><a href="#响应报文" aria-hidden="true" class="header-anchor">#</a> 响应报文</h4> <p>HTTP响应也由三个部分组成，分别是：<strong>状态行</strong>、<strong>响应头</strong>、<strong>空行</strong>、<strong>响应正文</strong>。 正如你所见，在响应中唯一真正的区别在于第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个状态码来说明所请求的资源情况。</p> <p>状态行格式如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>HTTP-Version    Status-Code    Reason-Phrase    CRLF
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>其中，HTTP-Version表示服务器HTTP协议的版本；</p> <p>Status-Code表示服务器发回的响应状态代码；</p> <p>Reason-Phrase表示状态代码的文本描述。</p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180813/E9c1HhEHmi.png?imageslim" alt="mark"></p> <p><strong>状态码</strong></p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180813/caCIjdI86a.png?imageslim" alt="mark"></p> <p><strong>常见的状态码</strong></p> <ul><li>200 OK：客户端请求成功。</li> <li>400 Bad Request：客户端请求有语法错误，不能被服务器所理解。</li> <li>401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。</li> <li>403 Forbidden：服务器收到请求，但是拒绝提供服务。</li> <li>404 Not Found：请求资源不存在，举个例子：输入了错误的URL。</li> <li>500 Internal Server Error：服务器发生不可预期的错误。</li> <li>503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。</li></ul> <p><strong>状态码列表</strong></p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180813/jBKKmAeFi1.png?imageslim" alt="mark"></p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180813/7A3Bk2cmjB.png?imageslim" alt="mark"></p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180813/j7a8HALDmC.png?imageslim" alt="mark"></p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180813/e1m8BJDB3g.png?imageslim" alt="mark"></p> <p><strong>HTTP响应头</strong></p> <p>常用的响应头部</p> <ul><li>Access-Control-Allow-Headers: 服务器端允许的请求Headers</li> <li>Access-Control-Allow-Methods: 服务器端允许的请求方法</li> <li>Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）</li> <li>Content-Type：服务端返回的实体内容的类型</li> <li>Date：数据从服务器发送的时间</li> <li>Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档</li> <li>Last-Modified：请求资源的最后修改时间</li> <li>Expires：应该在什么时候认为文档已经过期,从而不再缓存它</li> <li>Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效</li> <li>ETag：请求变量的实体标签的当前值</li> <li>Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端</li> <li>Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）</li> <li>Server：服务器的一些相关信息</li></ul> <p>一般来说，请求头部和响应头部是匹配分析的。</p> <p>譬如，请求头部的<code>Accept</code>要和响应头部的<code>Content-Type</code>匹配，否则会报错</p> <p>譬如，跨域请求时，请求头部的<code>Origin</code>要匹配响应头部的<code>Access-Control-Allow-Origin</code>，否则会报跨域错误</p> <p>譬如，在使用缓存时，请求头部的<code>If-Modified-Since</code>、<code>If-None-Match</code>分别和响应头部的<code>Last-Modified</code>、<code>ETag</code>对应</p> <h3 id="http-1-1"><a href="#http-1-1" aria-hidden="true" class="header-anchor">#</a> HTTP 1.1</h3> <p>与HTTP 1.0相比，主要区别体现在</p> <ol><li><p><strong>缓存处理</strong>：在HTTP 1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p></li> <li><p><strong>长连接</strong> ：HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p> <blockquote><p>HTTP Pipelining是这样一种技术：在等待上一个请求响应的同时，发送下一个请求。(译者注：作者这个解释并不完全正确，HTTP Pipelining其实是把多个HTTP请求放到一个TCP连接中一一发送，而在发送过程中不需要等待服务器对前一个请求的响应；<strong>只不过，客户端还是要按照发送请求的顺序来接收响应</strong>。)但就像在超市收银台或者银行柜台排队时一样，你并不知道前面的顾客是干脆利索的还是会跟收银员/柜员磨蹭到世界末日（译者注：不管怎么说，服务器（即收银员/柜员）是要按照顺序处理请求的，如果前一个请求非常耗时（顾客磨蹭），那么后续请求都会受到影响），<strong>这就是所谓的线头阻塞（Head of line blocking）</strong>。</p></blockquote></li></ol> <h3 id="http-2-0"><a href="#http-2-0" aria-hidden="true" class="header-anchor">#</a> HTTP 2.0</h3> <p>HTTP 2.0 相比于 HTTP 1.X，可以说是大幅度提高了 web 的性能。</p> <p>在 HTTP 1.X 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量，当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</p> <p>你可以通过 <a href="https://http2.akamai.com/demo" target="_blank" rel="noopener noreferrer">该链接<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 感受下 HTTP 2.0 比 HTTP 1.X 到底快了多少。</p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180813/4KB54j28Bl.png?imageslim" alt="mark"></p> <p><strong>HTTP2.0和HTTP1.X相比的新特性</strong></p> <ul><li><p><strong>新的二进制格式</strong>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180813/hH5JLllbhe.png?imageslim" alt="mark"></p></li> <li><p><strong>多路复用</strong>（MultiPlexing）</p> <p>在 HTTP 2.0 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。</p> <p>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</p> <p>多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180813/iEgeEffbeB.png?imageslim" alt="mark"></p></li> <li><p><strong>Header压缩</strong></p> <p>在 HTTP 1.X 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。</p> <p>在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。</p></li></ul> <p><strong>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？</strong></p> <ul><li>HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；</li> <li>HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；</li> <li>HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行</li></ul> <h3 id="https"><a href="#https" aria-hidden="true" class="header-anchor">#</a> <a href="https://baijiahao.baidu.com/s?id=1570143475599137&wfr=spider&for=pc" target="_blank" rel="noopener noreferrer">HTTPS<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3> <p>HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。</p> <h4 id="tls"><a href="#tls" aria-hidden="true" class="header-anchor">#</a> <strong>TLS</strong></h4> <p>TLS 协议位于传输层之上，应用层之下。首次进行 TLS 协议传输需要两个 RTT ，接下来可以通过 Session Resumption 减少到一个 RTT。</p> <p>在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。</p> <p><strong>对称加密</strong>：</p> <p>对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。</p> <p><strong>非对称加密</strong>：</p> <p>有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。</p> <p><strong>TLS 握手过程如下图：</strong></p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180813/AF3DBK44FF.png?imageslim" alt="mark"></p> <ol><li>客户端发送一个随机值，需要的协议和加密方式</li> <li>服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）</li> <li>客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书</li> <li>服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密</li></ol> <p>通过以上步骤可知，在 TLS 握手阶段，两端使用非对称加密的方式来通信，<u>但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。</u></p> <p>PS：以上说明的都是 TLS 1.2 协议的握手情况，在 1.3 协议中，首次建立连接只需要一个 RTT，后面恢复连接不需要 RTT 了。</p> <h2 id="tcp和udp"><a href="#tcp和udp" aria-hidden="true" class="header-anchor">#</a> TCP和UDP</h2> <h3 id="运输层与网络层的关系"><a href="#运输层与网络层的关系" aria-hidden="true" class="header-anchor">#</a> 运输层与网络层的关系</h3> <p>在协议栈中，运输层刚好位于网络层之上。网络层提供了<strong>主机之间</strong>的逻辑通信，而运输层为运行在不同主机上的<strong>进程之间</strong>提供了逻辑通信。</p> <h3 id="多路复用和多路分解"><a href="#多路复用和多路分解" aria-hidden="true" class="header-anchor">#</a> 多路复用和多路分解</h3> <p>一个进程（作为网络应用的一部分）有一个或多个套接字（socket），它相当于从网络向进程传递数据和从进程向网络传递数据的门户。因此，在<strong>接受主机中的运输层实际上并没有直接将数据交付给进程，而是将数据交给了一个中间的套接字</strong>。</p> <p>将运输层报文段报文段中的数据交付到正确的套接字（对应的端口号）的工作称为<strong>多路分解</strong>。</p> <p>在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在以后用于分解）从而生成报文段，然后将报文段传递到网络层，所有这些工作称为<strong>多路复用</strong>。</p> <h3 id="udp"><a href="#udp" aria-hidden="true" class="header-anchor">#</a> UDP</h3> <h4 id="特点"><a href="#特点" aria-hidden="true" class="header-anchor">#</a> 特点</h4> <p>UDP为调用它的应用程序提供了一种<strong>不可靠</strong>，<strong>无连接</strong>的服务。进程到进程的数据交付和差错检查是两种最低限度的运输层服务，也是UDP所能提供的仅有的两种服务。也就是说，在两个进程通信前没有握手过程，UDP并不保证该报文将到达接受进程，不仅如此，到达接受进程的报文也可能是乱序到达的。</p> <h4 id="报文段结构"><a href="#报文段结构" aria-hidden="true" class="header-anchor">#</a> 报文段结构</h4> <p>因为 UDP 没有 TCP 那么复杂，需要保证数据不丢失且有序到达。所以 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。</p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180815/k6CFCA4KhH.png?imageslim" alt="mark"></p> <p>头部包含了以下几个数据</p> <ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li> <li>整个数据报文的长度</li> <li>整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误</li></ul> <h4 id="为什么dns基于udp"><a href="#为什么dns基于udp" aria-hidden="true" class="header-anchor">#</a> 为什么DNS基于UDP</h4> <p>因为UDP是面向无连接 不要求准确 但是速度快DNS解析是一种查询服务 查询要求的是速度 并不是精确度 所以使用UDP的 如果用TCP一个查询要等很久的 。</p> <h3 id="tcp"><a href="#tcp" aria-hidden="true" class="header-anchor">#</a> <a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="noopener noreferrer">TCP<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3> <h4 id="面向连接服务"><a href="#面向连接服务" aria-hidden="true" class="header-anchor">#</a> 面向连接服务</h4> <p>在应用层数据报文开始流动之前，TCP让客户和服务器产生握手过程，提示客户和服务器，使它们为大量分组的到来做好准备。在握手阶段后，一个TCP就在两个进程的套接字之间建立了。这条连接是双全工的，即连接双方的进程可以在此连接上同时进行报文收发。</p> <h4 id="可靠的数据传送服务"><a href="#可靠的数据传送服务" aria-hidden="true" class="header-anchor">#</a> 可靠的数据传送服务</h4> <p>通信进程能够依靠TCP，无差错，按适当顺序交付所有发送的数据。</p> <h4 id="拥塞控制机制"><a href="#拥塞控制机制" aria-hidden="true" class="header-anchor">#</a> 拥塞控制机制</h4> <p>拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</p> <h4 id="头部"><a href="#头部" aria-hidden="true" class="header-anchor">#</a> 头部</h4> <p>TCP 头部比 UDP 头部复杂的多</p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180815/abIg2lfk56.png?imageslim" alt="mark"></p> <ul><li>Sequence number，这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文</li> <li>Acknowledgement Number，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到，不过，只有当标志位中的ACK标志（下面介绍）为1时该确认序列号的字段才有效。</li> <li>Window Size，窗口大小，表示还能接收多少字节的数据，用于流量控制</li> <li>标识符
<ul><li>URG=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。</li> <li>ACK=1：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为1。</li> <li>PSH=1：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。</li> <li>RST=1：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。</li> <li>SYN=1：表示同步序号，用来建立连接 ，当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。</li> <li>FIN=1：该字段为一表示此报文段是一个释放连接的请求报文。</li></ul></li></ul> <h4 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" aria-hidden="true" class="header-anchor">#</a> 三次握手与四次挥手</h4> <p>这里要祭出这张超经典的图了。</p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180815/Fbi5J7egkB.png?imageslim" alt="mark"></p> <p><strong>三次握手：</strong></p> <ol><li>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</li> <li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li> <li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。
完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。</li></ol> <p><strong>四次分手：</strong></p> <ol><li>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</li> <li>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</li> <li>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</li> <li>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li></ol> <p><strong>为什么要三次握手？</strong></p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180815/LLLJefdL3d.png?imageslim" alt="mark"></p> <p>这就很明白了，防止了服务器端的一直等待而浪费资源。</p> <p><strong>为什么要四次分手？</strong></p> <p>那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。</p> <p>TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p> <h3 id="websocket"><a href="#websocket" aria-hidden="true" class="header-anchor">#</a> WebSocket</h3> <h4 id="websocket是什么？"><a href="#websocket是什么？" aria-hidden="true" class="header-anchor">#</a> Websocket是什么？</h4> <p>WebSocket 是一种网络通信协议。RFC6455 定义了它的通信标准。</p> <p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p> <h4 id="为什么需要-websocket-？"><a href="#为什么需要-websocket-？" aria-hidden="true" class="header-anchor">#</a> 为什么需要 WebSocket ？</h4> <p>了解计算机网络协议的人，应该都知道：HTTP 协议是一种无状态的、无连接的、<strong>单向</strong>的应用层协议。它采用了请求/响应模型。通信请求只能由客户端发起，服务端对请求做出应答处理。</p> <p>这种通信模型有一个弊端：HTTP 协议无法实现服务器主动向客户端发起消息。</p> <p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。大多数 Web 应用程序将通过频繁的异步JavaScript和XML（AJAX）请求实现长轮询。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。</p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180815/ELhE28GDiK.png?imageslim" alt="mark"></p> <p>因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。WebSocket 连接允许客户端和服务器之间进行全双工通信，以便任一方都可以通过建立的连接将数据推送到另一端。WebSocket 只需要建立一次连接，就可以一直保持连接状态。这相比于轮询方式的不停建立连接显然效率要大大提高。</p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180815/c86lgIcHgd.png?imageslim" alt="mark"></p> <p>具体参数使用参考<a href="https://www.cnblogs.com/jingmoxukong/p/7755643.html" target="_blank" rel="noopener noreferrer">这里<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/network/从输入URL到页面加载说起.html" class="prev">
          从输入URL到页面加载说起
        </a></span> <span class="next"><a href="/network/HTTP缓存机制.html">
          HTTP缓存机制
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/40.92805123.js" defer></script><script src="/assets/js/app.813c17b6.js" defer></script>
  </body>
</html>
