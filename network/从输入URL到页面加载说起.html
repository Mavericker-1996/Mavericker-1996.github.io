<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>从输入URL到页面加载说起 | Mavericker&#39;s Blog</title>
    <meta name="description" content="Mavericker&#39;s Blog">
    <link rel="icon" href="/fav.ico">
    
    <link rel="preload" href="/assets/css/0.styles.76307617.css" as="style"><link rel="preload" href="/assets/js/app.b3cb7539.js" as="script"><link rel="preload" href="/assets/js/11.ece047ad.js" as="script"><link rel="prefetch" href="/assets/js/6.d10f6abe.js"><link rel="prefetch" href="/assets/js/2.cda51ec0.js"><link rel="prefetch" href="/assets/js/3.3656e9a0.js"><link rel="prefetch" href="/assets/js/4.4223daab.js"><link rel="prefetch" href="/assets/js/5.d16be197.js"><link rel="prefetch" href="/assets/js/7.628fc77d.js"><link rel="prefetch" href="/assets/js/8.e1a712a0.js"><link rel="prefetch" href="/assets/js/9.9f24e45e.js"><link rel="prefetch" href="/assets/js/10.e1f9c9fc.js"><link rel="prefetch" href="/assets/js/12.b5ed552c.js"><link rel="prefetch" href="/assets/js/13.19ca3436.js">
    <link rel="stylesheet" href="/assets/css/0.styles.76307617.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Mavericker's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/network/" class="nav-link router-link-active">网络</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/javascript/javascript基础/" class="nav-link">JavaScript基础</a></li><li class="dropdown-item"><!----> <a href="/javascript/javascript专题/" class="nav-link">JavaScript专题</a></li></ul></div></div><div class="nav-item"><a href="/vue/" class="nav-link">Vue</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/resume/" class="nav-link">个人简历</a></div><div class="nav-item"><a href="https://github.com/Mavericker-1996/myblog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/network/" class="nav-link router-link-active">网络</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/javascript/javascript基础/" class="nav-link">JavaScript基础</a></li><li class="dropdown-item"><!----> <a href="/javascript/javascript专题/" class="nav-link">JavaScript专题</a></li></ul></div></div><div class="nav-item"><a href="/vue/" class="nav-link">Vue</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></div><div class="nav-item"><a href="/resume/" class="nav-link">个人简历</a></div><div class="nav-item"><a href="https://github.com/Mavericker-1996/myblog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/network/" class="sidebar-link">写在前面的话</a></li><li><a href="/network/从输入URL到页面加载说起.html" class="active sidebar-link">从输入URL到页面加载说起</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#_1-ajax" class="sidebar-link">1. ajax</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#_2-区分进程与线程" class="sidebar-link">2. 区分进程与线程</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#_3-浏览器都包含哪些进程？" class="sidebar-link">3. 浏览器都包含哪些进程？</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#_4-重点是浏览器内核（渲染进程）" class="sidebar-link">4. 重点是浏览器内核（渲染进程）</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#_5-browser进程和浏览器内核（renderer进程）的通信过程" class="sidebar-link">5. Browser进程和浏览器内核（Renderer进程）的通信过程</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#_6-梳理浏览器内核中线程之间的关系" class="sidebar-link">6. 梳理浏览器内核中线程之间的关系</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#webworker，js的多线程？" class="sidebar-link">WebWorker，JS的多线程？</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#webworker与sharedworker" class="sidebar-link">WebWorker与SharedWorker</a></li></ul></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#_7-解析页面流程" class="sidebar-link">7. 解析页面流程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#流程简述" class="sidebar-link">流程简述</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#html解析，构建dom" class="sidebar-link">HTML解析，构建DOM</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#生成css规则" class="sidebar-link">生成CSS规则</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#构建渲染树" class="sidebar-link">构建渲染树</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#渲染" class="sidebar-link">渲染</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#简单层与复合层" class="sidebar-link">简单层与复合层</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#chrome中的调试" class="sidebar-link">Chrome中的调试</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#资源外链的下载" class="sidebar-link">资源外链的下载</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#css的可视化格式模型" class="sidebar-link">CSS的可视化格式模型</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#包含块（containing-block）" class="sidebar-link">包含块（Containing Block）</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#控制框（controlling-box）" class="sidebar-link">控制框（Controlling Box）</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#bfc（block-formatting-context）" class="sidebar-link">BFC（Block Formatting Context）</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#ifc（inline-formatting-context）" class="sidebar-link">IFC（Inline Formatting Context）</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#其它" class="sidebar-link">其它</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#loaded和domcontentloaded" class="sidebar-link">loaded和domcontentloaded</a></li></ul></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#_8-从event-loop谈js的运行机制" class="sidebar-link">8. 从Event Loop谈JS的运行机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#事件循环机制进一步补充" class="sidebar-link">事件循环机制进一步补充</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#单独说说定时器" class="sidebar-link">单独说说定时器</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#事件循环进阶：macrotask与microtask" class="sidebar-link">事件循环进阶：macrotask与microtask</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#事件机制" class="sidebar-link">事件机制</a></li></ul></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#_9-解析url" class="sidebar-link">9. 解析URL</a></li><li class="sidebar-sub-header"><a href="/network/从输入URL到页面加载说起.html#_10-网络请求都是单独的线程" class="sidebar-link">10. 网络请求都是单独的线程</a></li></ul></li><li><a href="/network/ajax跨域.html" class="sidebar-link">ajax跨域</a></li><li><a href="/network/HTTP缓存机制.html" class="sidebar-link">HTTP缓存机制</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="从输入url到页面加载说起"><a href="#从输入url到页面加载说起" aria-hidden="true" class="header-anchor">#</a> 从输入URL到页面加载说起</h1> <h2 id="_1-ajax"><a href="#_1-ajax" aria-hidden="true" class="header-anchor">#</a> 1. ajax</h2> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180728/d113L755EF.png?imageslim" alt="mark"></p> <h2 id="_2-区分进程与线程"><a href="#_2-区分进程与线程" aria-hidden="true" class="header-anchor">#</a> 2. 区分进程与线程</h2> <p>线程和进程区分不清，是很多新手都会犯的错误，没有关系。这很正常。先看看下面这个形象的比喻：</p> <div class="language- extra-class"><pre class="language-text"><code>- 进程是一个工厂，工厂有它的独立资源

- 工厂之间相互独立

- 线程是工厂中的工人，多个工人协作完成任务

- 工厂内有一个或多个工人

- 工人之间共享空间
</code></pre></div><p>再完善完善概念：</p> <div class="language- extra-class"><pre class="language-text"><code>- 工厂的资源 -&gt; 系统分配的内存（独立的一块内存）

- 工厂之间的相互独立 -&gt; 进程之间相互独立

- 多个工人协作完成任务 -&gt; 多个线程在进程中协作完成任务

- 工厂内有一个或多个工人 -&gt; 一个进程由一个或多个线程组成

- 工人之间共享空间 -&gt; 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）
</code></pre></div><p>进程是cpu==资源分配==的==最小单位==（是能拥有资源和独立运行的最小单位）</p> <p>线程是cpu==调度的最小单位==（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</p> <h2 id="_3-浏览器都包含哪些进程？"><a href="#_3-浏览器都包含哪些进程？" aria-hidden="true" class="header-anchor">#</a> 3. 浏览器都包含哪些进程？</h2> <p>知道了浏览器是多进程后，再来看看它到底包含哪些进程：（为了简化理解，仅列举主要进程）</p> <ol><li>Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有
<ul><li>负责浏览器界面显示，与用户交互。如前进，后退等</li> <li>负责各个页面的管理，创建和销毁其他进程</li> <li>将Renderer进程得到的内存中的Bitmap，绘制到用户界面上</li> <li>网络资源的管理，下载等</li></ul></li> <li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li> <li>GPU进程：最多一个，用于3D绘制等</li> <li>==浏览器渲染进程（浏览器内核）==（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为
<ul><li>页面渲染，脚本执行，事件处理等</li></ul></li></ol> <p>强化记忆：==<strong>在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）</strong>==</p> <h2 id="_4-重点是浏览器内核（渲染进程）"><a href="#_4-重点是浏览器内核（渲染进程）" aria-hidden="true" class="header-anchor">#</a> 4. 重点是浏览器内核（渲染进程）</h2> <p>可以这样理解，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。接下来重点分析这个进程</p> <p><strong>请牢记，浏览器的渲染进程是多线程的</strong>（这点如果不理解，<strong>请回头看进程和线程的区分</strong>）</p> <p>终于到了线程这个概念了?，好亲切。那么接下来看看它都包含了哪些线程（列举一些主要常驻线程）：</p> <ol><li>GUI渲染线程
<ul><li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</li> <li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li> <li>注意，==<strong>GUI渲染线程与JS引擎线程是互斥的</strong>==，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中==<strong>等到JS引擎空闲时</strong>==立即被执行。</li></ul></li> <li>JS引擎线程
<ul><li>也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）</li> <li>JS引擎线程负责解析Javascript脚本，运行代码。</li> <li>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都==只有一个JS线程==在运行JS程序</li> <li>同样注意，<strong>GUI渲染线程与JS引擎线程是互斥的</strong>，所以如果JS执行的时间过长，==这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞==。</li></ul></li> <li>事件触发线程
<ul><li>归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</li> <li>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中</li> <li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</li> <li>注意，由于==JS的单线程关系==，所以这些==待处理队列中的事件都得排队等待JS引擎处理==（当JS引擎空闲时才会去执行）</li></ul></li> <li>定时触发器线程
<ul><li>传说中的<code>setInterval</code>与<code>setTimeout</code>所在线程</li> <li>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</li> <li>因此通过单独线程来计时并触发定时（==计时完毕后，添加到事件队列==中，等待JS引擎空闲后执行）</li> <li>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</li></ul></li> <li>异步http请求线程
<ul><li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</li> <li>将检测到状态变更时，如果设置有回调函数，异步线程就<strong>产生状态变更事件</strong>，将这个回调再放入事件队列中。再由JavaScript引擎执行。</li></ul></li></ol> <p>看到这里，如果觉得累了，可以先休息下，这些概念需要被消化，毕竟后续将提到的事件循环机制就是基于<code>事件触发线程</code>的，所以如果仅仅是看某个碎片化知识，
可能会有一种似懂非懂的感觉。要完成的梳理一遍才能快速沉淀，不易遗忘。放张图巩固下吧：</p> <p><img src="https://segmentfault.com/img/remote/1460000012925880?w=287&h=577" alt="img"></p> <p>再说一点，为什么JS引擎是单线程的？额，这个问题其实应该没有标准答案，譬如，可能仅仅是因为由于多线程的复杂性，譬如多线程操作一般要加锁，因此最初设计时选择了单线程。。。</p> <h2 id="_5-browser进程和浏览器内核（renderer进程）的通信过程"><a href="#_5-browser进程和浏览器内核（renderer进程）的通信过程" aria-hidden="true" class="header-anchor">#</a> 5. Browser进程和浏览器内核（Renderer进程）的通信过程</h2> <p>看到这里，首先，应该对浏览器内的进程和线程都有一定理解了，那么接下来，再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的，
这点也理解后，就可以将这部分的知识串联起来，从头到尾有一个完整的概念。</p> <p>如果自己打开任务管理器，然后打开一个浏览器，就可以看到：==<strong>任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程）</strong>==，
然后在这前提下，看下整个的过程：(简化了很多)</p> <ul><li>Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程</li> <li>Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染
<ul><li>渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染</li> <li>当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）</li> <li>==最后Render进程将结果传递给Browser进程==</li></ul></li> <li>Browser进程接收到结果并将结果绘制出来</li></ul> <p>这里绘一张简单的图：（很简化）</p> <p><img src="https://segmentfault.com/img/remote/1460000012925881?w=470&h=325" alt="img"></p> <p>看完这一整套流程，应该对浏览器的运作有了一定理解了，这样有了知识架构的基础后，后续就方便往上填充内容。</p> <h2 id="_6-梳理浏览器内核中线程之间的关系"><a href="#_6-梳理浏览器内核中线程之间的关系" aria-hidden="true" class="header-anchor">#</a> 6. 梳理浏览器内核中线程之间的关系</h2> <h3 id="webworker，js的多线程？"><a href="#webworker，js的多线程？" aria-hidden="true" class="header-anchor">#</a> WebWorker，JS的多线程？</h3> <p>前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？</p> <p>所以，后来HTML5中支持了<code>Web Worker</code>。</p> <p>MDN的官方解释是：</p> <div class="language- extra-class"><pre class="language-text"><code>Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面

一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件 

这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window

因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误
</code></pre></div><p>这样理解下：</p> <ul><li>创建Worker时，JS引擎向浏览器申请开一个子线程（==子线程是浏览器开的，完全受主线程控制，而且不能操作DOM==）</li> <li>JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）</li></ul> <p>==所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程==，
只待计算出结果后，将结果通信给主线程即可，perfect!</p> <p>而且注意下，<strong>JS引擎是单线程的</strong>，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。</p> <p>其它，关于Worker的详解就不是本文的范畴了，因此不再赘述。</p> <h3 id="webworker与sharedworker"><a href="#webworker与sharedworker" aria-hidden="true" class="header-anchor">#</a> WebWorker与SharedWorker</h3> <p>既然都到了这里，就再提一下<code>SharedWorker</code>（避免后续将这两个概念搞混）</p> <ul><li>WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享
<ul><li>所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。</li></ul></li> <li>SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用
<ul><li>所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。</li></ul></li></ul> <p>看到这里，应该就很容易明白了，本质上就是进程和线程的区别。==SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程==</p> <h2 id="_7-解析页面流程"><a href="#_7-解析页面流程" aria-hidden="true" class="header-anchor">#</a> 7. 解析页面流程</h2> <p>前面有提到http交互，那么接下来就是浏览器获取到html，然后解析，渲染</p> <p><strong>这部分很多都参考了网上资源，特别是图片，参考了来源中的文章</strong></p> <h3 id="流程简述"><a href="#流程简述" aria-hidden="true" class="header-anchor">#</a> 流程简述</h3> <p>浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：</p> <div class="language- extra-class"><pre class="language-text"><code>1. 解析HTML，构建DOM树

2. 解析CSS，生成CSS规则树

3. 合并DOM树和CSS规则，生成render树

4. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算

5. 绘制render树（paint），绘制页面像素信息

6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上
</code></pre></div><p>如下图：</p> <p><img src="https://segmentfault.com/img/remote/1460000013662138?w=900&h=352" alt="img"></p> <h3 id="html解析，构建dom"><a href="#html解析，构建dom" aria-hidden="true" class="header-anchor">#</a> HTML解析，构建DOM</h3> <p>整个渲染步骤中，HTML解析是第一步。</p> <p>简单的理解，这一步的流程是这样的：<strong>浏览器解析HTML，构建DOM树。</strong></p> <p>但实际上，在分析整体构建时，却不能一笔带过，得稍微展开。</p> <p>解析HTML到构建出DOM当然过程可以简述如下：</p> <div class="language- extra-class"><pre class="language-text"><code>Bytes → characters → tokens → nodes → DOM
</code></pre></div><p>譬如假设有这样一个HTML页面：（以下部分的内容出自参考来源，修改了下格式）</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;html&gt;
  &lt;head&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;
    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;
    &lt;title&gt;Critical Path&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;
    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre></div><p>浏览器的处理如下：</p> <p><img src="https://segmentfault.com/img/remote/1460000013662139?w=900&h=498" alt="img"></p> <p>列举其中的一些重点过程：</p> <div class="language- extra-class"><pre class="language-text"><code>1. Conversion转换：浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符

2. Tokenizing分词：浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集

3. Lexing词法分析：分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则

4. DOM构建：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样
例如：body对象的父节点就是HTML对象，然后段略p对象的父节点就是body对象
</code></pre></div><p>最后的DOM树如下：</p> <p><img src="https://segmentfault.com/img/remote/1460000013662140?w=665&h=284" alt="img"></p> <h3 id="生成css规则"><a href="#生成css规则" aria-hidden="true" class="header-anchor">#</a> 生成CSS规则</h3> <p>同理，CSS规则树的生成也是类似。简述为：</p> <div class="language- extra-class"><pre class="language-text"><code>Bytes → characters → tokens → nodes → CSSOM
</code></pre></div><p>譬如<code>style.css</code>内容如下：</p> <div class="language- extra-class"><pre class="language-text"><code>body { font-size: 16px }
p { font-weight: bold }
span { color: red }
p span { display: none }
img { float: right }
</code></pre></div><p>那么最终的CSSOM树就是：</p> <p><img src="https://segmentfault.com/img/remote/1460000013662141?w=582&h=299" alt="img"></p> <h3 id="构建渲染树"><a href="#构建渲染树" aria-hidden="true" class="header-anchor">#</a> 构建渲染树</h3> <p>当DOM树和CSSOM都有了后，就要开始构建渲染树了</p> <p>一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应</p> <p>因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者<code>display: none</code>等</p> <p>整体来说可以看图：</p> <p><img src="https://segmentfault.com/img/remote/1460000013662142?w=900&h=420" alt="img"></p> <h3 id="渲染"><a href="#渲染" aria-hidden="true" class="header-anchor">#</a> 渲染</h3> <p>有了render树，接下来就是开始渲染，基本流程如下：</p> <p><img src="https://segmentfault.com/img/remote/1460000013662143?w=900&h=248" alt="img"></p> <p>图中重要的四个步骤就是：</p> <div class="language- extra-class"><pre class="language-text"><code>1. 计算CSS样式

2. 构建渲染树

3. 布局，主要定位坐标和大小，是否换行，各种position overflow z-index属性

4. 绘制，将图像绘制出来
</code></pre></div><p>然后，图中的线与箭头代表通过js动态修改了DOM或CSS，导致了重新布局（Layout）或渲染（Repaint）</p> <p>这里Layout和Repaint的概念是有区别的：</p> <ul><li>Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树</li> <li>Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了</li></ul> <p>回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流，
所以优化方案中一般都包括，尽量避免回流。</p> <p><strong>什么会引起回流？</strong></p> <div class="language- extra-class"><pre class="language-text"><code>1.页面渲染初始化

2.DOM结构改变，比如删除了某个节点

3.render树变化，比如减少了padding

4.窗口resize

5.最复杂的一种：获取某些属性，引发回流，
很多浏览器会对回流做优化，会等到数量足够时做一次批处理回流，
但是除了render树的直接变化，当获取一些属性时，浏览器为了获得正确的值也会触发回流，这样使得浏览器优化无效，包括
    （1）offset(Top/Left/Width/Height)
     (2) scroll(Top/Left/Width/Height)
     (3) cilent(Top/Left/Width/Height)
     (4) width,height
     (5) 调用了getComputedStyle()或者IE的currentStyle
</code></pre></div><p>回流一定伴随着重绘，重绘却可以单独出现</p> <p>所以一般会有一些优化方案，如：</p> <ul><li>减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新</li> <li>避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document</li> <li>避免多次读取offset等属性。无法避免则将它们缓存到变量</li> <li>将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高</li></ul> <p><strong>注意：改变字体大小会引发回流</strong></p> <p>再来看一个示例：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> s <span class="token operator">=</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>style<span class="token punctuation">;</span>

s<span class="token punctuation">.</span>padding <span class="token operator">=</span> <span class="token string">&quot;2px&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 回流+重绘</span>
s<span class="token punctuation">.</span>border <span class="token operator">=</span> <span class="token string">&quot;1px solid red&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 再一次 回流+重绘</span>
s<span class="token punctuation">.</span>color <span class="token operator">=</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 再一次重绘</span>
s<span class="token punctuation">.</span>backgroundColor <span class="token operator">=</span> <span class="token string">&quot;#ccc&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 再一次 重绘</span>
s<span class="token punctuation">.</span>fontSize <span class="token operator">=</span> <span class="token string">&quot;14px&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 再一次 回流+重绘</span>
<span class="token comment">// 添加node，再一次 回流+重绘</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span><span class="token string">'abc!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="简单层与复合层"><a href="#简单层与复合层" aria-hidden="true" class="header-anchor">#</a> 简单层与复合层</h3> <p>上述中的渲染中止步于绘制，但实际上绘制这一步也没有这么简单，它可以结合复合层和简单层的概念来讲。</p> <p>这里不展开，进简单介绍下：</p> <ul><li>可以认为默认只有一个复合图层，所有的DOM节点都是在这个复合图层下的</li> <li>如果开启了硬件加速功能，可以将某个节点变成复合图层</li> <li>复合图层之间的绘制互不干扰，由GPU直接控制</li> <li>而简单图层中，就算是absolute等布局，变化时不影响整体的回流，但是由于在同一个图层中，仍然是会影响绘制的，因此做动画时性能仍然很低。而复合层是独立的，所以一般做动画推荐使用硬件加速</li></ul> <p>更多参考：</p> <p><a href="https://segmentfault.com/a/1190000012925872#articleHeader16" target="_blank" rel="noopener noreferrer">普通图层和复合图层<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="chrome中的调试"><a href="#chrome中的调试" aria-hidden="true" class="header-anchor">#</a> Chrome中的调试</h3> <p>Chrome的开发者工具中，Performance中可以看到详细的渲染过程：</p> <p><img src="https://segmentfault.com/img/remote/1460000013662144?w=900&h=432" alt="img"> <img src="https://segmentfault.com/img/remote/1460000013662145?w=900&h=437" alt="img"></p> <h3 id="资源外链的下载"><a href="#资源外链的下载" aria-hidden="true" class="header-anchor">#</a> 资源外链的下载</h3> <p>上面介绍了html解析，渲染流程。但实际上，在解析html时，会遇到一些资源连接，此时就需要进行单独处理了</p> <p>简单起见，这里将遇到的静态资源分为一下几大类（未列举所有）：</p> <ul><li>CSS样式资源</li> <li>JS脚本资源</li> <li>img图片类资源</li></ul> <p><strong>遇到外链时的处理</strong></p> <p>当遇到上述的外链时，==会单独开启一个下载线程去下载资源（http1.1中是每一个资源的下载都要开启一个http请求，对应一个tcp/ip链接）==</p> <p><strong>遇到CSS样式资源</strong></p> <p>CSS资源的处理有几个特点：</p> <ul><li><p>==CSS下载时异步，不会阻塞浏览器构建DOM树==</p></li> <li><p>但是会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）</p></li> <li><p>有例外，<code>media query</code>声明的CSS是不会阻塞渲染的</p> <p>这可能也是浏览器的一种优化机制。</p> <p>因为你加载css的时候，可能会修改下面DOM节点的样式，
如果css加载不阻塞render树渲染的话，那么当css加载完之后，
render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。
所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，
在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。</p></li></ul> <p><strong>遇到JS脚本资源</strong></p> <p>JS脚本资源的处理有几个特点：</p> <ul><li>阻塞浏览器的解析，也就是说发现一个外链脚本时，==需等待脚本下载完成并执行后才会继续解析HTML==</li> <li>浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已</li> <li>defer与async，普通的脚本是会阻塞浏览器解析的，但是可以加上defer或async属性，这样脚本就变成异步了，可以等到解析完毕后再执行</li></ul> <p>注意，defer和async是有区别的： <strong>defer是延迟执行，而async是异步执行。</strong></p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180729/HbJKGF2L9j.png?imageslim" alt="mark"></p> <p>简单的说（不展开）：</p> <ul><li><code>async</code>是异步执行，==异步下载完毕后就会执行，不确保执行顺序==，一定在<code>onload</code>前，但不确定在<code>DOMContentLoaded</code>事件的前或后</li> <li><code>defer</code>是延迟执行，在浏览器看起来的效果像是将脚本放在了<code>body</code>后面一样（虽然按规范应该是在<code>DOMContentLoaded</code>事件前，但实际上不同浏览器的优化效果不一样，也有可能在它后面）</li></ul> <p><strong>遇到img图片类资源</strong></p> <p>遇到图片等资源时==，直接就是异步下载，不会阻塞解析==，下载完毕后直接用图片替换原有src的地方</p> <h3 id="css的可视化格式模型"><a href="#css的可视化格式模型" aria-hidden="true" class="header-anchor">#</a> CSS的可视化格式模型</h3> <p><strong>这一部分内容很多参考《精通CSS-高级Web标准解决方案》以及参考来源</strong></p> <p>前面提到了整体的渲染概念，但实际上文档树中的元素是按什么渲染规则渲染的，是可以进一步展开的，此部分内容即： <strong>CSS的可视化格式模型</strong></p> <p>先了解：</p> <ul><li>==CSS中规定每一个元素都有自己的盒子模型（相当于规定了这个元素如何显示）==</li> <li>==然后可视化格式模型则是把这些盒子按照规则摆放到页面上，也就是如何布局==</li> <li>换句话说，盒子模型规定了怎么在页面里摆放盒子，盒子的相互作用等等</li></ul> <p>说到底： <strong>CSS的可视化格式模型就是规定了浏览器在页面中如何处理文档树</strong></p> <p>关键字：</p> <div class="language- extra-class"><pre class="language-text"><code>包含块（Containing Block）
控制框（Controlling Box）
BFC（Block Formatting Context）
IFC（Inline Formatting Context）
定位体系
浮动
...
</code></pre></div><p>另外，CSS有三种定位机制：<code>普通流</code>，<code>浮动</code>，<code>绝对定位</code>，如无特别提及，下文中都是针对普通流中的</p> <h3 id="包含块（containing-block）"><a href="#包含块（containing-block）" aria-hidden="true" class="header-anchor">#</a> 包含块（Containing Block）</h3> <p>一个元素的box的定位和尺寸，会与某一矩形框有关，这个框就称之为包含块。</p> <p>元素会为它的子孙元素创建包含块，但是，并不是说元素的包含块就是它的父元素，元素的包含块与它的祖先元素的样式等有关系</p> <p>譬如：</p> <ul><li>根元素是最顶端的元素，它没有父节点，它的包含块就是初始包含块</li> <li>static和relative的包含块由它最近的块级、单元格或者行内块祖先元素的内容框（content）创建</li> <li>fixed的包含块是当前可视窗口</li> <li>absolute的包含块由它最近的position 属性为<code>absolute</code>、<code>relative</code>或者<code>fixed</code>的祖先元素创建
<ul><li>如果其祖先元素是行内元素，则包含块取决于其祖先元素的<code>direction</code>特性</li> <li>如果祖先元素不是行内元素，那么包含块的区域应该是祖先元素的内边距边界</li></ul></li></ul> <h3 id="控制框（controlling-box）"><a href="#控制框（controlling-box）" aria-hidden="true" class="header-anchor">#</a> 控制框（Controlling Box）</h3> <p>块级元素和块框以及行内元素和行框的相关概念</p> <p><strong>块框:</strong></p> <ul><li>块级元素会生成一个块框（<code>Block Box</code>），块框会占据一整行，用来包含子box和生成的内容</li> <li>块框同时也是一个块包含框（<code>Containing Box</code>），里面要么只包含块框，要么只包含行内框（不能混杂），如果块框内部有块级元素也有行内元素，那么行内元素会被匿名块框包围</li></ul> <p>关于<strong>匿名块框</strong>的生成，示例：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;DIV&gt;
Some text
&lt;P&gt;More text
&lt;/DIV&gt;
</code></pre></div><p><code>div</code>生成了一个块框，包含了另一个块框<code>p</code>以及文本内容<code>Some text</code>，此时<code>Some text</code>文本会被强制加到一个匿名的块框里面，被<code>div</code>生成的块框包含（其实这个就是<code>IFC</code>中提到的行框，包含这些行内框的这一行匿名块形成的框，行框和行内框不同）</p> <p>换句话说:</p> <p><strong>如果一个块框在其中包含另外一个块框，那么我们强迫它只能包含块框，因此其它文本内容生成出来的都是匿名块框（而不是匿名行内框）</strong></p> <p><strong>行内框：</strong></p> <ul><li>一个行内元素生成一个行内框</li> <li>行内元素能排在一行，允许左右有其它元素</li></ul> <p>关于<strong>匿名行内框</strong>的生成，示例：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;P&gt;Some &lt;EM&gt;emphasized&lt;/EM&gt; text&lt;/P&gt;
</code></pre></div><p><code>P</code>元素生成一个块框，其中有几个行内框（如<code>EM</code>），以及文本<code>Some</code>，<code>text</code>，此时会专门为这些文本生成匿名行内框</p> <p><strong>display属性的影响</strong></p> <p><code>display</code>的几个属性也可以影响不同框的生成：</p> <ul><li><code>block</code>，元素生成一个块框</li> <li><code>inline</code>，元素产生一个或多个的行内框</li> <li><code>inline-block</code>，元素产生一个行内级块框，行内块框的内部会被当作块块来格式化，而此元素本身会被当作行内级框来格式化（这也是为什么会产生<code>BFC</code>）</li> <li><code>none</code>，不生成框，不再格式化结构中，当然了，另一个<code>visibility: hidden</code>则会产生一个不可见的框</li></ul> <p>总结：</p> <ul><li>如果一个框里，有一个块级元素，那么这个框里的内容都会被当作块框来进行格式化，因为只要出现了块级元素，就会将里面的内容分块几块，每一块独占一行（出现行内可以用匿名块框解决）</li> <li>如果一个框里，没有任何块级元素，那么这个框里的内容会被当成行内框来格式化，因为里面的内容是按照顺序成行的排列</li></ul> <h3 id="bfc（block-formatting-context）"><a href="#bfc（block-formatting-context）" aria-hidden="true" class="header-anchor">#</a> BFC（Block Formatting Context）</h3> <p>FC（格式上下文）？</p> <p>FC即格式上下文，它定义框内部的元素渲染规则，比较抽象，譬如</p> <div class="language- extra-class"><pre class="language-text"><code>FC像是一个大箱子，里面装有很多元素

箱子可以隔开里面的元素和外面的元素（所以外部并不会影响FC内部的渲染）

内部的规则可以是：如何定位，宽高计算，margin折叠等等
</code></pre></div><p>不同类型的框参与的FC类型不同，譬如块级框对应BFC，行内框对应IFC</p> <p><strong>注意，并不是说所有的框都会产生FC，而是符合特定条件才会产生，只有产生了对应的FC后才会应用对应渲染规则</strong></p> <p><strong>BFC规则：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>在块格式化上下文中

每一个元素左外边与包含块的左边相接触（对于从右到左的格式化，右外边接触右边）

即使存在浮动也是如此（所以浮动元素正常会直接贴近它的包含块的左边，与普通元素重合）

除非这个元素也创建了一个新的BFC
</code></pre></div><p>总结几点BFC特点：</p> <ol><li>内部<code>box</code>在垂直方向，一个接一个的放置</li> <li>box的垂直方向由<code>margin</code>决定，属于同一个BFC的两个box间的margin会重叠</li> <li>BFC区域不会与<code>float box</code>重叠（可用于排版)</li> <li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此</li> <li>计算BFC的高度时，浮动元素也参与计算（不会浮动坍塌）</li></ol> <p>如何触发BFC？</p> <ol><li>根元素</li> <li><code>float</code>属性不为<code>none</code></li> <li><code>position</code>为<code>absolute</code>或<code>fixed</code></li> <li><code>display</code>为<code>inline-block</code>, <code>flex</code>, <code>inline-flex</code>，<code>table</code>，<code>table-cell</code>，<code>table-caption</code></li> <li><code>overflow</code>不为<code>visible</code></li></ol> <p>这里提下，<code>display: table</code>，它本身不产生BFC，但是它会产生匿名框（包含<code>display: table-cell</code>的框），而这个匿名框产生BFC</p> <p>更多请自行网上搜索</p> <h3 id="ifc（inline-formatting-context）"><a href="#ifc（inline-formatting-context）" aria-hidden="true" class="header-anchor">#</a> IFC（Inline Formatting Context）</h3> <p>IFC即行内框产生的格式上下文</p> <p><strong>IFC规则</strong></p> <div class="language- extra-class"><pre class="language-text"><code>在行内格式化上下文中

框一个接一个地水平排列，起点是包含块的顶部。

水平方向上的 margin，border 和 padding 在框之间得到保留

框在垂直方向上可以以不同的方式对齐：它们的顶部或底部对齐，或根据其中文字的基线对齐
</code></pre></div><p><strong>行框</strong></p> <p><strong>包含那些框的长方形区域，会形成一行，叫做行框</strong></p> <p>行框的宽度由它的包含块和其中的浮动元素决定，高度的确定由行高度计算规则决定</p> <p>行框的规则：</p> <div class="language- extra-class"><pre class="language-text"><code>如果几个行内框在水平方向无法放入一个行框内，它们可以分配在两个或多个垂直堆叠的行框中（即行内框的分割）

行框在堆叠时没有垂直方向上的分割且永不重叠

行框的高度总是足够容纳所包含的所有框。不过，它可能高于它包含的最高的框（例如，框对齐会引起基线对齐）

行框的左边接触到其包含块的左边，右边接触到其包含块的右边。
</code></pre></div><p><strong>结合补充下IFC规则：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>浮动元素可能会处于包含块边缘和行框边缘之间

尽管在相同的行内格式化上下文中的行框通常拥有相同的宽度（包含块的宽度），它们可能会因浮动元素缩短了可用宽度，而在宽度上发生变化

同一行内格式化上下文中的行框通常高度不一样（如，一行包含了一个高的图形，而其它行只包含文本）

当一行中行内框宽度的总和小于包含它们的行框的宽，它们在水平方向上的对齐，取决于 `text-align` 特性

空的行内框应该被忽略

即不包含文本，保留空白符，margin/padding/border非0的行内元素，
以及其他常规流中的内容(比如，图片，inline blocks 和 inline tables)，
并且不是以换行结束的行框，
必须被当作零高度行框对待
</code></pre></div><p>总结：</p> <ul><li>行内元素总是会应用IFC渲染规则</li> <li>行内元素会应用IFC规则渲染，譬如<code>text-align</code>可以用来居中等</li> <li>块框内部，对于文本这类的匿名元素，会产生匿名行框包围，而行框内部就应用IFC渲染规则</li> <li>行内框内部，对于那些行内元素，一样应用IFC渲染规则</li> <li>另外，<code>inline-block</code>，会在元素外层产生IFC（所以这个元素是可以通过<code>text-align</code>水平居中的），当然，它内部则按照BFC规则渲染</li></ul> <p>相比BFC规则来说，IFC可能更加抽象（因为没有那么条理清晰的规则和触发条件）</p> <p>但总的来说，它就是行内元素自身如何显示以及在框内如何摆放的渲染规则，这样描述应该更容易理解</p> <h3 id="其它"><a href="#其它" aria-hidden="true" class="header-anchor">#</a> 其它</h3> <p>当然还有有一些其它内容：</p> <ul><li>譬如常规流，浮动，绝对定位等区别</li> <li>譬如浮动元素不包含在常规流中</li> <li>譬如相对定位，绝对定位，<code>Fixed</code>定位等区别</li> <li>譬如<code>z-index</code>的分层显示机制等</li></ul> <p>这里不一一展开，更多请参考：</p> <p><a href="http://bbs.csdn.net/topics/340204423" target="_blank" rel="noopener noreferrer">http://bbs.csdn.net/topics/340204423<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="loaded和domcontentloaded"><a href="#loaded和domcontentloaded" aria-hidden="true" class="header-anchor">#</a> loaded和domcontentloaded</h3> <p>简单的对比：</p> <ul><li>DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片(譬如如果有async加载的脚本就不一定完成)</li> <li>load 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了</li></ul> <h2 id="_8-从event-loop谈js的运行机制"><a href="#_8-从event-loop谈js的运行机制" aria-hidden="true" class="header-anchor">#</a> 8. 从Event Loop谈JS的运行机制</h2> <p>读这部分的前提是已经知道了JS引擎是单线程，而且这里会用到上文中的几个概念：（如果不是很理解，可以回头温习）</p> <ul><li>JS引擎线程</li> <li>事件触发线程</li> <li>定时触发器线程</li></ul> <p>然后再理解一个概念：</p> <ul><li>JS分为同步任务和异步任务</li> <li>==同步任务都在主线程上执行，形成一个<code>执行栈</code>==</li> <li>主线程之外，<strong>事件触发线程</strong>管理着一个<code>任务队列</code>，==只要异步任务有了运行结果==，就在<code>任务队列</code>之中放置一个事件。</li> <li>一旦<code>执行栈</code>中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取<code>任务队列</code>，将可运行的异步任务添加到可执行栈中，开始执行。</li></ul> <p>看图：</p> <p><img src="https://segmentfault.com/img/remote/1460000012925883?w=610&h=637" alt="img"></p> <p>看到这里，应该就可以理解了：为什么有时候setTimeout推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码，
所以自然有误差。</p> <h3 id="事件循环机制进一步补充"><a href="#事件循环机制进一步补充" aria-hidden="true" class="header-anchor">#</a> 事件循环机制进一步补充</h3> <p>这里就直接引用一张图片来协助理解：（参考自Philip Roberts的演讲《<a href="http://vimeo.com/96425312" target="_blank" rel="noopener noreferrer">Help, I'm stuck in an event-loop<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》）</p> <p><img src="https://segmentfault.com/img/remote/1460000012925884?w=636&h=518" alt="img"></p> <p>上图大致描述就是：</p> <ul><li>主线程运行时会产生执行栈，</li></ul> <p>栈中的代码调用某些api时，它们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕）</p> <ul><li>而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调</li> <li>如此循环</li> <li>注意，==总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件==</li></ul> <h3 id="单独说说定时器"><a href="#单独说说定时器" aria-hidden="true" class="header-anchor">#</a> 单独说说定时器</h3> <p>上述事件循环机制的核心是：JS引擎线程和事件触发线程</p> <p>但事件上，里面还有一些隐藏细节，譬如调用<code>setTimeout</code>后，是如何等待特定时间后才添加到事件队列中的？</p> <p>是JS引擎检测的么？当然不是了。它是由<strong>定时器线程</strong>控制（因为JS引擎自己都忙不过来，根本无暇分身）</p> <p>为什么要单独的定时器线程？因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。</p> <p>什么时候会用到定时器线程？<strong>当使用setTimeout或setInterval时</strong>，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。</p> <p>譬如:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这段代码的作用是当<code>1000</code>毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'begin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行</p> <p>注意：</p> <ul><li>执行结果是：先<code>begin</code>后<code>hello!</code></li> <li>虽然代码的本意是0毫秒后就推入事件队列，但是W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</li></ul> <p>(不过也有一说是不同浏览器有不同的最小时间设定)</p> <ul><li>就算不等待4ms，就算假设0毫秒就推入事件队列，也会先执行<code>begin</code>（因为只有可执行栈内空了后才会主动读取事件队列）</li></ul> <h3 id="事件循环进阶：macrotask与microtask"><a href="#事件循环进阶：macrotask与microtask" aria-hidden="true" class="header-anchor">#</a> 事件循环进阶：macrotask与microtask</h3> <p>这段参考了参考来源中的第2篇文章（英文版的），（加了下自己的理解重新描述了下），
强烈推荐有英文基础的同学直接观看原文，作者描述的很清晰，示例也很不错，如下：</p> <p><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener noreferrer">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>上文中将JS事件循环机制梳理了一遍，在ES5的情况是够用了，但是在ES6盛行的现在，仍然会遇到一些问题，譬如下面这题：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>嗯哼，它的正确执行顺序是这样子的：</p> <div class="language- extra-class"><pre class="language-text"><code>script start
script end
promise1
promise2
setTimeout
</code></pre></div><p>为什么呢？因为Promise里有了一个一个新的概念：<code>microtask</code></p> <p>或者，进一步，JS中分为两种任务类型：<strong>macrotask和microtask</strong>，在ECMAScript中，microtask称为<code>jobs</code>，macrotask可称为<code>task</code></p> <p>它们的定义？区别？简单点可以按如下理解：</p> <ul><li>macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）
<ul><li>每一个task会从头到尾将这个任务执行完毕，不会执行其它</li> <li>浏览器为了能够使得JS内部task与DOM任务能够有序的执行，==会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染==</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>（`task-&gt;渲染-&gt;task-&gt;...`）
</code></pre></div><ul><li>microtask（又称为微任务），==可以理解是在当前 task 执行结束后立即执行的任务==
<ul><li>也就是说，在当前task任务后，下一个task之前，在渲染之前</li> <li>所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染</li> <li>也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）</li></ul></li></ul> <p>分别很么样的场景会形成macrotask和microtask呢？</p> <ul><li>macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask）</li> <li>microtask：Promise，process.nextTick等</li></ul> <p><strong>补充：在node环境下，process.nextTick的优先级高于Promise</strong>，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。</p> <p>参考：<a href="https://segmentfault.com/q/1010000011914016" target="_blank" rel="noopener noreferrer">https://segmentfault.com/q/1010000011914016<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>再根据线程来理解下：</p> <ul><li>macrotask中的事件都是放在一个事件队列中的，而这个队列由<strong>事件触发线程</strong>维护</li> <li>microtask中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由<strong>JS引擎线程维护</strong></li></ul> <p>（这点由自己理解+推测得出，因为它是在主线程下无缝执行的）</p> <p>所以，总结下运行机制：</p> <ul><li>==执行一个宏任务（栈中没有就从事件队列中获取==）</li> <li>==执行过程中如果遇到微任务，就将它添加到微任务的任务队列中==</li> <li>==宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）==</li> <li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li> <li>==渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）==</li></ul> <p>如图：</p> <p><img src="https://segmentfault.com/img/remote/1460000012925885?w=392&h=740" alt="img"></p> <p>另外，请注意下<code>Promise</code>的<code>polyfill</code>与官方版本的区别：</p> <ul><li>官方版本中，是标准的microtask形式</li> <li>polyfill，一般都是通过setTimeout模拟的，所以是macrotask形式</li> <li>请特别注意这两点区别</li></ul> <p>注意，有一些浏览器执行结果不一样（因为它们可能把microtask当成macrotask来执行了），
但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准）</p> <p>也可以参考文章：<a href="https://github.com/dwqs/blog/issues/61" target="_blank" rel="noopener noreferrer">从一道题浅说 JavaScript 的事件循环<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="事件机制"><a href="#事件机制" aria-hidden="true" class="header-anchor">#</a> <a href="https://www.cnblogs.com/chenluomenggongzi/p/5758109.html" target="_blank" rel="noopener noreferrer">事件机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></h3> <hr> <h4 id="事件触发三阶段"><a href="#事件触发三阶段" aria-hidden="true" class="header-anchor">#</a> 事件触发三阶段</h4> <p>事件触发有三个阶段</p> <ul><li><p><code>document</code> 往事件触发处传播，遇到注册的==捕获事件==会触发</p></li> <li><p>传播到事件触发处时==触发注册==的事件</p></li> <li><p>从事件触发处往 <code>document</code> 传播，遇到注册的==冒泡事件==会触发</p> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180801/1LkJhc1E43.png?imageslim" alt="mark"></p> <p>除了采用addEventListener绑定事件可以用于定义捕捉阶段和冒泡阶段触发事件， 其它绑定事件的方法只在==冒泡阶段==触发事件。</p></li></ul> <h4 id="事件代理或事件委托"><a href="#事件代理或事件委托" aria-hidden="true" class="header-anchor">#</a> 事件代理或事件委托</h4> <p>事件委托的原理：</p> <p>事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件</p> <p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">&lt;</span>ul id<span class="token operator">=</span><span class="token string">&quot;ul&quot;</span><span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>li<span class="token operator">&gt;</span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>li<span class="token operator">&gt;</span><span class="token number">2</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>li<span class="token operator">&gt;</span><span class="token number">3</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>li<span class="token operator">&gt;</span><span class="token number">4</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>li<span class="token operator">&gt;</span><span class="token number">5</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
	<span class="token keyword">let</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span>
	ul<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">//	兼容性处理</span>
        <span class="token keyword">var</span> event <span class="token operator">=</span> event <span class="token operator">||</span> window<span class="token punctuation">.</span>event<span class="token punctuation">;</span>
        <span class="token keyword">var</span> target <span class="token operator">=</span> event<span class="token punctuation">.</span>target <span class="token operator">||</span> event<span class="token punctuation">.</span>srcElement<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>nodeName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
           console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre></div><p>上面的例子是说li操作的是同样的效果，要是每个li被点击的效果都不一样，那么用事件委托还有用吗？</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;box&quot;</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;button&quot;</span> id<span class="token operator">=</span><span class="token string">&quot;add&quot;</span> value<span class="token operator">=</span><span class="token string">&quot;添加&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;button&quot;</span> id<span class="token operator">=</span><span class="token string">&quot;remove&quot;</span> value<span class="token operator">=</span><span class="token string">&quot;删除&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;button&quot;</span> id<span class="token operator">=</span><span class="token string">&quot;move&quot;</span> value<span class="token operator">=</span><span class="token string">&quot;移动&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;button&quot;</span> id<span class="token operator">=</span><span class="token string">&quot;select&quot;</span> value<span class="token operator">=</span><span class="token string">&quot;选择&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code>window<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">var</span> Add <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;add&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">var</span> Remove <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;remove&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">var</span> Move <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;move&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">var</span> Select <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;select&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            
            Add<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'添加'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
            Remove<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'删除'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
            Move<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'移动'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
            Select<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'选择'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            
        <span class="token punctuation">}</span>
</code></pre></div><p>上面实现的效果我就不多说了，很简单，4个按钮，点击每一个做不同的操作，那么至少需要4次dom操作，如果用事件委托，能进行优化吗？</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>window<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">var</span> oBox <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;box&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            oBox<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>ev<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">var</span> ev <span class="token operator">=</span> ev <span class="token operator">||</span> window<span class="token punctuation">.</span>event<span class="token punctuation">;</span>
                <span class="token keyword">var</span> target <span class="token operator">=</span> ev<span class="token punctuation">.</span>target <span class="token operator">||</span> ev<span class="token punctuation">.</span>srcElement<span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>nodeName<span class="token punctuation">.</span><span class="token function">toLocaleLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'input'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">switch</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">{</span>
                        <span class="token keyword">case</span> <span class="token string">'add'</span> <span class="token punctuation">:</span>
                            <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'添加'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                        <span class="token keyword">case</span> <span class="token string">'remove'</span> <span class="token punctuation">:</span>
                            <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'删除'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                        <span class="token keyword">case</span> <span class="token string">'move'</span> <span class="token punctuation">:</span>
                            <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'移动'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                        <span class="token keyword">case</span> <span class="token string">'select'</span> <span class="token punctuation">:</span>
                            <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'选择'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>         
        <span class="token punctuation">}</span>
</code></pre></div><p>用事件委托就可以只用一次dom操作就能完成所有的效果，比上面的性能肯定是要好一些的</p> <p>现在讲的都是document加载完成的现有dom节点下的操作，那么如果是新增的节点，新增的节点会有事件吗？也就是说，一个新员工来了，他能收到快递吗？</p> <p>看一下正常的添加节点的方法：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>button<span class="token punctuation">&quot;</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span><span class="token punctuation">&quot;</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>btn<span class="token punctuation">&quot;</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>添加<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>ul1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>111<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>222<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>333<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>444<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>现在是移入li，li变红，移出li，li变白，这么一个效果，然后点击按钮，可以向ul中添加一个li子节点</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>window<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">var</span> oBtn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;btn&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">var</span> oUl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;ul1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">var</span> aLi <span class="token operator">=</span> oUl<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
            
            <span class="token comment">//鼠标移入变红，移出变白</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>aLi<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                aLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onmouseover</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">this</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">;</span>
                aLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onmouseout</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">this</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">'#fff'</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//添加新节点</span>
            oBtn<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                num<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token keyword">var</span> oLi <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                oLi<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token number">111</span><span class="token operator">*</span>num<span class="token punctuation">;</span>
                oUl<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>oLi<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre></div><p>这是一般的做法，但是你会发现，新增的li是没有事件的，说明添加子节点的时候，事件没有一起添加进去，这不是我们想要的结果，那怎么做呢？一般的解决方案会是这样，将for循环用一个函数包起来，命名为mHover，如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>window<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">var</span> oBtn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;btn&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">var</span> oUl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;ul1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">var</span> aLi <span class="token operator">=</span> oUl<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
            
            <span class="token keyword">function</span> <span class="token function">mHover</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">//鼠标移入变红，移出变白</span>
                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>aLi<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    aLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onmouseover</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                        <span class="token keyword">this</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">'red'</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span><span class="token punctuation">;</span>
                    aLi<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function-variable function">onmouseout</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                        <span class="token keyword">this</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">'#fff'</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token function">mHover</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//添加新节点</span>
            oBtn<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                num<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token keyword">var</span> oLi <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                oLi<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token number">111</span><span class="token operator">*</span>num<span class="token punctuation">;</span>
                oUl<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>oLi<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">mHover</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre></div><p>虽然功能实现了，看着还挺好，但实际上无疑==是又增加了一个dom操作==，在优化性能方面是不可取的，那么有事件委托的方式，能做到优化吗？</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>window<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">var</span> oBtn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;btn&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">var</span> oUl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;ul1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">var</span> aLi <span class="token operator">=</span> oUl<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
            
            <span class="token comment">//事件委托，添加的子元素也有事件</span>
            oUl<span class="token punctuation">.</span><span class="token function-variable function">onmouseover</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">var</span> ev <span class="token operator">=</span> ev <span class="token operator">||</span> window<span class="token punctuation">.</span>event<span class="token punctuation">;</span>
                <span class="token keyword">var</span> target <span class="token operator">=</span> ev<span class="token punctuation">.</span>target <span class="token operator">||</span> ev<span class="token punctuation">.</span>srcElement<span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>nodeName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    target<span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">&quot;red&quot;</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
            oUl<span class="token punctuation">.</span><span class="token function-variable function">onmouseout</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">var</span> ev <span class="token operator">=</span> ev <span class="token operator">||</span> window<span class="token punctuation">.</span>event<span class="token punctuation">;</span>
                <span class="token keyword">var</span> target <span class="token operator">=</span> ev<span class="token punctuation">.</span>target <span class="token operator">||</span> ev<span class="token punctuation">.</span>srcElement<span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>nodeName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    target<span class="token punctuation">.</span>style<span class="token punctuation">.</span>background <span class="token operator">=</span> <span class="token string">&quot;#fff&quot;</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
            
            <span class="token comment">//添加新节点</span>
            oBtn<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                num<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token keyword">var</span> oLi <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                oLi<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token number">111</span><span class="token operator">*</span>num<span class="token punctuation">;</span>
                oUl<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>oLi<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre></div><p>看，上面是用事件委托的方式，新添加的子元素是带有事件效果的，我们可以发现，==当用事件委托的时候，根本就不需要去遍历元素的子节点，只需要给父级元素添加事件就好了，其他的都是在js里面的执行，这样可以大大的减少dom操作，这才是事件委托的精髓所在。==</p> <p>事件代理的方式相对于直接给目标注册事件来说，有以下优点</p> <ul><li>节省内存</li> <li>不需要给子节点注销事件</li></ul> <p><img src="http://ofluknnfq.bkt.clouddn.com/blog/180801/kkAC36h7lK.png?imageslim" alt="mark"></p> <p>当然，事件委托也是有一定局限性的；</p> <p>比如 ==focus、blur 之类的事件本身没有事件冒泡机制==，所以无法委托；</p> <p>mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的；</p> <h2 id="_9-解析url"><a href="#_9-解析url" aria-hidden="true" class="header-anchor">#</a> 9. 解析URL</h2> <p>输入URL后，==会进行解析==（URL的本质就是统一资源定位符）</p> <p>URL一般包括几大部分：</p> <ul><li><code>protocol</code>，协议头，譬如有http，ftp等</li> <li><code>host</code>，主机域名或IP地址</li> <li><code>port</code>，端口号</li> <li><code>path</code>，目录路径</li> <li><code>query</code>，即查询参数</li> <li><code>fragment</code>，即<code>#</code>后的hash值，一般用来定位到某个位置</li></ul> <h2 id="_10-网络请求都是单独的线程"><a href="#_10-网络请求都是单独的线程" aria-hidden="true" class="header-anchor">#</a> 10. 网络请求都是单独的线程</h2> <p>每次网络请求时都需要开辟==单独的线程==进行，譬如如果URL解析到http协议，就会新建一个网络线程去处理资源下载</p> <p>因此浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源（这里，暂时理解为是浏览器内核开辟的，如有错误，后续修复）</p></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/network/" class="prev router-link-active">
          写在前面的话
        </a></span> <span class="next"><a href="/network/ajax跨域.html">
          ajax跨域
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/11.ece047ad.js" defer></script><script src="/assets/js/app.b3cb7539.js" defer></script>
  </body>
</html>
