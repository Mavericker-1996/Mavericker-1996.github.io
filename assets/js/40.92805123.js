(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{214:function(t,e,s){"use strict";s.r(e);var r=s(0),i=Object(r.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),s("p",[t._v("简要概括就是：")]),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),s("p",[t._v("在五层的应用层和传输层之间增加了表示层和会话层。")]),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),s("h3",{attrs:{id:"dns查找"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dns查找","aria-hidden":"true"}},[t._v("#")]),t._v(" "),s("a",{attrs:{href:"https://www.cnblogs.com/xsilence/p/6035559.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("DNS查找"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("浏览器DNS查找顺序一般是这样的：浏览器缓存→系统缓存→路由器缓存→ISP DNS 缓存→递归搜索。")]),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),s("p",[t._v("​        操作系统没有设定浏览器存储DNS记录的时间长短，不同的浏览器会存储各自的一个固定时间，时长为2~30分钟不等。")]),t._v(" "),t._m(15),t._v(" "),s("p",[t._v("​        如果浏览器缓存里没有找到需要的记录，浏览器会做一个操作系统调用（windows里是gethostname），这样子，就可以获得系统缓存里的记录啦。")]),t._v(" "),t._m(16),t._v(" "),s("p",[t._v("​        接下来，如果还是没有找到需要的缓存，将前面的查询请求发给路由器，它一般会有自己的DNS缓存。")]),t._v(" "),t._m(17),t._v(" "),s("p",[t._v("​        每一个ISP（网络服务提供商），或一个大学，甚至是一个大学里的系都会有一个自己的本地域名服务器，他会在url第一次访问时缓存该域名的指向。下次再访问时，他会从缓存里把这个url曾经指向的IP调出来。")]),t._v(" "),t._m(18),t._v(" "),s("p",[t._v("​        还是没有需要的缓存~ 就只能放大招啦~\n你的ISP的DNS服务器会从根域名开始进行递归查询。")]),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),s("p",[t._v("​        如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其根域名服务器继续发出查询请求报文(即替主机继续查询)，接着根域名服务器访问顶级域服务器，接着权威DNS服务器，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是返回一个失败的响应，表示无法查询到所需的IP地址。")]),t._v(" "),t._m(21),t._v(" "),t._m(22),t._v(" "),s("p",[t._v("​        当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么返回给本地域名服务器所要查询的IP地址，要么返回给本地域名服务器下一步应当查询的域名服务器的IP地址。")]),t._v(" "),t._m(23),t._v(" "),t._m(24),t._v(" "),s("h4",{attrs:{id:"正向代理与反向代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#正向代理与反向代理","aria-hidden":"true"}},[t._v("#")]),t._v(" "),s("a",{attrs:{href:"https://www.cnblogs.com/Anker/p/6056540.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("正向代理与反向代理"),s("OutboundLink")],1)]),t._v(" "),s("ol",[t._m(25),t._v(" "),t._m(26),t._v(" "),t._m(27),t._v(" "),s("li",[t._m(28),t._v(" "),s("p",[t._v("可以参考这个"),s("a",{attrs:{href:"https://blog.csdn.net/zhanghanboke/article/details/77488894",target:"_blank",rel:"noopener noreferrer"}},[t._v("网站"),s("OutboundLink")],1)])])]),t._v(" "),t._m(29),t._v(" "),t._m(30),t._v(" "),t._m(31),t._v(" "),t._m(32),t._v(" "),t._m(33),t._v(" "),s("ol",[t._m(34),t._v(" "),t._m(35),t._v(" "),s("li",[t._m(36),t._v(" "),s("ul",[t._m(37),t._v(" "),t._m(38),t._v(" "),t._m(39),t._v(" "),s("li",[s("p",[t._v("GET和POST区别")]),t._v(" "),s("p",[t._v("可参考这个"),s("a",{attrs:{href:"https://www.cnblogs.com/longm/p/7205318.html?utm_source=itdadao&utm_medium=referral",target:"_blank",rel:"noopener noreferrer"}},[t._v("链接"),s("OutboundLink")],1)])])])])]),t._v(" "),t._m(40),t._v(" "),t._m(41),t._v(" "),s("p",[t._v("状态行格式如下：")]),t._v(" "),t._m(42),s("p",[t._v("其中，HTTP-Version表示服务器HTTP协议的版本；")]),t._v(" "),s("p",[t._v("Status-Code表示服务器发回的响应状态代码；")]),t._v(" "),s("p",[t._v("Reason-Phrase表示状态代码的文本描述。")]),t._v(" "),t._m(43),t._v(" "),t._m(44),t._v(" "),t._m(45),t._v(" "),t._m(46),t._v(" "),t._m(47),t._v(" "),t._m(48),t._v(" "),t._m(49),t._v(" "),t._m(50),t._v(" "),t._m(51),t._v(" "),t._m(52),t._v(" "),t._m(53),t._v(" "),s("p",[t._v("常用的响应头部")]),t._v(" "),t._m(54),t._v(" "),s("p",[t._v("一般来说，请求头部和响应头部是匹配分析的。")]),t._v(" "),t._m(55),t._v(" "),t._m(56),t._v(" "),t._m(57),t._v(" "),t._m(58),t._v(" "),s("p",[t._v("与HTTP 1.0相比，主要区别体现在")]),t._v(" "),t._m(59),t._v(" "),t._m(60),t._v(" "),s("p",[t._v("HTTP 2.0 相比于 HTTP 1.X，可以说是大幅度提高了 web 的性能。")]),t._v(" "),s("p",[t._v("在 HTTP 1.X 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量，当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。")]),t._v(" "),s("p",[t._v("你可以通过 "),s("a",{attrs:{href:"https://http2.akamai.com/demo",target:"_blank",rel:"noopener noreferrer"}},[t._v("该链接"),s("OutboundLink")],1),t._v(" 感受下 HTTP 2.0 比 HTTP 1.X 到底快了多少。")]),t._v(" "),t._m(61),t._v(" "),t._m(62),t._v(" "),t._m(63),t._v(" "),t._m(64),t._v(" "),t._m(65),t._v(" "),s("h3",{attrs:{id:"https"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#https","aria-hidden":"true"}},[t._v("#")]),t._v(" "),s("a",{attrs:{href:"https://baijiahao.baidu.com/s?id=1570143475599137&wfr=spider&for=pc",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTPS"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。")]),t._v(" "),t._m(66),t._v(" "),s("p",[t._v("TLS 协议位于传输层之上，应用层之下。首次进行 TLS 协议传输需要两个 RTT ，接下来可以通过 Session Resumption 减少到一个 RTT。")]),t._v(" "),s("p",[t._v("在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。")]),t._v(" "),t._m(67),t._v(" "),s("p",[t._v("对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。")]),t._v(" "),t._m(68),t._v(" "),s("p",[t._v("有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。")]),t._v(" "),t._m(69),t._v(" "),t._m(70),t._v(" "),t._m(71),t._v(" "),t._m(72),t._v(" "),s("p",[t._v("PS：以上说明的都是 TLS 1.2 协议的握手情况，在 1.3 协议中，首次建立连接只需要一个 RTT，后面恢复连接不需要 RTT 了。")]),t._v(" "),t._m(73),t._v(" "),t._m(74),t._v(" "),t._m(75),t._v(" "),t._m(76),t._v(" "),t._m(77),t._v(" "),t._m(78),t._v(" "),t._m(79),t._v(" "),t._m(80),t._v(" "),t._m(81),t._v(" "),t._m(82),t._v(" "),t._m(83),t._v(" "),s("p",[t._v("因为 UDP 没有 TCP 那么复杂，需要保证数据不丢失且有序到达。所以 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。")]),t._v(" "),t._m(84),t._v(" "),s("p",[t._v("头部包含了以下几个数据")]),t._v(" "),t._m(85),t._v(" "),t._m(86),t._v(" "),s("p",[t._v("因为UDP是面向无连接 不要求准确 但是速度快DNS解析是一种查询服务 查询要求的是速度 并不是精确度 所以使用UDP的 如果用TCP一个查询要等很久的 。")]),t._v(" "),s("h3",{attrs:{id:"tcp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp","aria-hidden":"true"}},[t._v("#")]),t._v(" "),s("a",{attrs:{href:"https://github.com/jawil/blog/issues/14",target:"_blank",rel:"noopener noreferrer"}},[t._v("TCP"),s("OutboundLink")],1)]),t._v(" "),t._m(87),t._v(" "),s("p",[t._v("在应用层数据报文开始流动之前，TCP让客户和服务器产生握手过程，提示客户和服务器，使它们为大量分组的到来做好准备。在握手阶段后，一个TCP就在两个进程的套接字之间建立了。这条连接是双全工的，即连接双方的进程可以在此连接上同时进行报文收发。")]),t._v(" "),t._m(88),t._v(" "),s("p",[t._v("通信进程能够依靠TCP，无差错，按适当顺序交付所有发送的数据。")]),t._v(" "),t._m(89),t._v(" "),s("p",[t._v("拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。")]),t._v(" "),t._m(90),t._v(" "),s("p",[t._v("TCP 头部比 UDP 头部复杂的多")]),t._v(" "),t._m(91),t._v(" "),t._m(92),t._v(" "),t._m(93),t._v(" "),s("p",[t._v("这里要祭出这张超经典的图了。")]),t._v(" "),t._m(94),t._v(" "),t._m(95),t._v(" "),t._m(96),t._v(" "),t._m(97),t._v(" "),t._m(98),t._v(" "),t._m(99),t._v(" "),t._m(100),t._v(" "),s("p",[t._v("这就很明白了，防止了服务器端的一直等待而浪费资源。")]),t._v(" "),t._m(101),t._v(" "),s("p",[t._v("那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。")]),t._v(" "),s("p",[t._v("TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。")]),t._v(" "),t._m(102),t._v(" "),t._m(103),t._v(" "),s("p",[t._v("WebSocket 是一种网络通信协议。RFC6455 定义了它的通信标准。")]),t._v(" "),s("p",[t._v("WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。")]),t._v(" "),t._m(104),t._v(" "),t._m(105),t._v(" "),s("p",[t._v("这种通信模型有一个弊端：HTTP 协议无法实现服务器主动向客户端发起消息。")]),t._v(" "),s("p",[t._v("这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。大多数 Web 应用程序将通过频繁的异步JavaScript和XML（AJAX）请求实现长轮询。轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。")]),t._v(" "),t._m(106),t._v(" "),s("p",[t._v("因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。WebSocket 连接允许客户端和服务器之间进行全双工通信，以便任一方都可以通过建立的连接将数据推送到另一端。WebSocket 只需要建立一次连接，就可以一直保持连接状态。这相比于轮询方式的不停建立连接显然效率要大大提高。")]),t._v(" "),t._m(107),t._v(" "),s("p",[t._v("具体参数使用参考"),s("a",{attrs:{href:"https://www.cnblogs.com/jingmoxukong/p/7755643.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),s("OutboundLink")],1)])])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协议","aria-hidden":"true"}},[this._v("#")]),this._v(" 协议")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"协议分层"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协议分层","aria-hidden":"true"}},[this._v("#")]),this._v(" 协议分层")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"五层因特网协议栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五层因特网协议栈","aria-hidden":"true"}},[this._v("#")]),this._v(" 五层因特网协议栈")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("1."),e("strong",[this._v("应用层")]),this._v("(dns,http) DNS解析成IP并发送http请求")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("2."),e("strong",[this._v("传输层")]),this._v("(tcp,udp) 建立tcp连接（三次握手）")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("3."),e("strong",[this._v("网络层")]),this._v("(IP,ARP) IP寻址")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("4."),e("strong",[this._v("数据链路层")]),this._v("(PPP) 封装成帧")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("5."),e("strong",[this._v("物理层")]),this._v("(利用物理介质传输比特流) 物理传输（然后传输的时候通过双绞线，电磁波等各种介质）")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("从应用层的发送http请求，到传输层通过三次握手建立tcp/ip连接，再到网络层的ip寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"七层osi框架"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#七层osi框架","aria-hidden":"true"}},[this._v("#")]),this._v(" 七层OSI框架")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("表示层")]),this._v(" 主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("会话层")]),this._v(" 它具体管理不同用户和进程之间的对话，如控制登陆和注销过程")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"dns协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dns协议","aria-hidden":"true"}},[this._v("#")]),this._v(" DNS协议")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"详细过程如下："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#详细过程如下：","aria-hidden":"true"}},[this._v("#")]),this._v(" 详细过程如下：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"a-浏览器缓存，浏览器会缓存dns记录一段时间。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#a-浏览器缓存，浏览器会缓存dns记录一段时间。","aria-hidden":"true"}},[this._v("#")]),this._v(" a. 浏览器缓存，浏览器会缓存DNS记录一段时间。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"b-系统缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#b-系统缓存","aria-hidden":"true"}},[this._v("#")]),this._v(" b. 系统缓存")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"c-路由器缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#c-路由器缓存","aria-hidden":"true"}},[this._v("#")]),this._v(" c. 路由器缓存")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"d-如果还是没有，那么就去检查isp有没有吧"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#d-如果还是没有，那么就去检查isp有没有吧","aria-hidden":"true"}},[this._v("#")]),this._v(" d. 如果还是没有，那么就去检查ISP有没有吧~")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"e-递归搜索"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#e-递归搜索","aria-hidden":"true"}},[this._v("#")]),this._v(" e. 递归搜索")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h5",{attrs:{id:"递归查询："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#递归查询：","aria-hidden":"true"}},[this._v("#")]),this._v(" "),e("strong",[this._v("递归查询")]),this._v("：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("​        主机向本地域名服务器的查询一般都是采用"),e("strong",[this._v("递归查询")]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h5",{attrs:{id:"迭代查询："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#迭代查询：","aria-hidden":"true"}},[this._v("#")]),this._v(" "),e("strong",[this._v("迭代查询")]),this._v("：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("​        本地域名服务器向根域名服务器的查询通常是采用"),e("strong",[this._v("迭代查询")]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"负载均衡"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡","aria-hidden":"true"}},[this._v("#")]),this._v(" 负载均衡")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合"),e("u",[this._v("反向代理")]),this._v("实现负载均衡。")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("li",[s("p",[s("strong",[t._v("正向代理")])]),t._v(" "),s("h6",{attrs:{id:"正向代理类似一个跳板机，代理访问外部资源。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#正向代理类似一个跳板机，代理访问外部资源。","aria-hidden":"true"}},[t._v("#")]),t._v(" 正向代理类似一个跳板机，代理访问外部资源。")]),t._v(" "),s("p",[s("img",{attrs:{src:"http://mavericker.oss-cn-beijing.aliyuncs.com/18-12-24/10680180.jpg",alt:""}})]),t._v(" "),s("p",[t._v("举个例子：")]),t._v(" "),s("p",[t._v("我是一个用户，我访问不了某网站，但是我能访问一个代理服务器，这个代理服务器呢,他能访问那个我不能访问的网站，于是我先连上代理服务器,告诉他我需要那个无法访问网站的内容，代理服务器去取回来,然后返回给我。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏了用户的资料，这取决于代理告不告诉网站。")]),t._v(" "),s("p",[s("strong",[t._v("客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。")])]),t._v(" "),s("p",[t._v("总结来说：正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。")])])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("li",[s("p",[s("strong",[t._v("反向代理")])]),t._v(" "),s("p",[t._v("初次接触方向代理的感觉是，客户端是无感知代理的存在的，反向代理对外都是透明的，访问者者并不知道自己访问的是一个代理。因为客户端"),s("u",[t._v("不需要任何配置")]),t._v("就可以访问。")]),t._v(" "),s("p",[t._v("反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。")]),t._v(" "),s("p",[t._v("反向代理的作用")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("保证内网的安全，可以使用反向代理提供WAF功能，阻止web攻击")]),t._v(" "),s("p",[t._v("大型网站，通常将反向代理作为公网访问地址，Web服务器是内网。")]),t._v(" "),s("p",[s("img",{attrs:{src:"http://ofluknnfq.bkt.clouddn.com/blog/180813/JBE751djLB.png?imageslim",alt:"mark"}})])]),t._v(" "),s("li",[s("p",[t._v("负载均衡，通过反向代理服务器来优化网站的负载")]),t._v(" "),s("p",[s("img",{attrs:{src:"http://ofluknnfq.bkt.clouddn.com/blog/180813/fD4kkKKc52.png?imageslim",alt:"mark"}})])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("li",[e("p",[e("strong",[this._v("两者区别")])]),this._v(" "),e("p",[e("img",{attrs:{src:"http://ofluknnfq.bkt.clouddn.com/blog/180813/431EID4C9h.png?imageslim",alt:"mark"}})])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("正向代理与反向代理通俗理解")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"http协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http协议","aria-hidden":"true"}},[this._v("#")]),this._v(" HTTP协议")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"http报文格式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http报文格式","aria-hidden":"true"}},[this._v("#")]),this._v(" HTTP报文格式")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"请求报文"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请求报文","aria-hidden":"true"}},[this._v("#")]),this._v(" 请求报文")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("一个HTTP请求报文由请求行（request line）、请求头（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。 回车符换行符即"),e("code",[this._v("\\r")]),this._v(" "),e("code",[this._v("\\n")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"http://ofluknnfq.bkt.clouddn.com/blog/180811/kl4mjCB578.png?imageslim",alt:"mark"}})])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("li",[s("p",[s("strong",[t._v("请求行")])]),t._v(" "),s("p",[t._v("请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如，")]),t._v(" "),s("p",[s("code",[t._v("GET /index.html HTTP/1.1")])]),t._v(" "),s("p",[t._v("根据HTTP标准，HTTP请求可以使用多种请求方法。 HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。")]),t._v(" "),s("p",[s("img",{attrs:{src:"http://ofluknnfq.bkt.clouddn.com/blog/180813/GDcECEI2ca.png?imageslim",alt:"mark"}})])])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("li",[s("p",[s("strong",[t._v("请求头")])]),t._v(" "),s("p",[t._v("常用的请求头部：")]),t._v(" "),s("ul",[s("li",[t._v("Accept：接受类型，表示浏览器支持的MIMIE类型")]),t._v(" "),s("li",[t._v("Accept-Encoding：浏览器支持的压缩类型，如gzip等。超出类型不能接受")]),t._v(" "),s("li",[t._v("Content-Type：客户端发送出去实体内容的类型")]),t._v(" "),s("li",[t._v("Cahe-Control：指定请求和响应遵循的缓存机制，如no-cache")]),t._v(" "),s("li",[t._v("If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中")]),t._v(" "),s("li",[t._v("Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间")]),t._v(" "),s("li",[t._v("Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中")]),t._v(" "),s("li",[t._v("If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中")]),t._v(" "),s("li",[t._v("Cookie: 有cookie并且"),s("strong",[t._v("同域访问")]),t._v("时会自动带上")]),t._v(" "),s("li",[t._v("Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive")]),t._v(" "),s("li",[t._v("Host：请求的服务器URL")]),t._v(" "),s("li",[t._v("Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私")]),t._v(" "),s("li",[t._v("Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)")]),t._v(" "),s("li",[t._v("User-Agent：用户客户端的一些必要信息，如UA头部等")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("GET和POST请求")])])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("li",[s("p",[t._v("GET")]),t._v(" "),s("p",[t._v("使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号"),s("code",[t._v("?")]),t._v("代表URL的结尾与请求参数的开始，各个参数之间"),s("code",[t._v("&")]),t._v("符号隔开传递参数长度受限制。 显然，这种方式不适合传送"),s("u",[t._v("私密数据")]),t._v("。另外，由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别1024个字符，"),s("u",[t._v("所以如果需要传送大量数据的时候，也不适合使用GET方式")]),t._v("。")]),t._v(" "),s("p",[t._v("常见的GET报文")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('GET /search?hl=zh-CN&source=hp&q=domety&aq=f&oq= HTTP/1.1  \nAccept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, \napplication/msword, application/x-silverlight, application/x-shockwave-flash, */*  \nReferer: <a href="http://www.google.cn/">http://www.google.cn/</a>  \nAccept-Language: zh-cn  \nAccept-Encoding: gzip, deflate  \nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  \nHost: <a href="http://www.google.cn">www.google.cn</a>  \nConnection: Keep-Alive  \nCookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; \nNID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-\nFxlRugatx63JLv7CWMD6UB_O_r \n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br")])])])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("li",[s("p",[t._v("POST")]),t._v(" "),s("p",[t._v("对于上面提到的不适合使用GET方式的情况，可以考虑使用POST方式，因为使用POST方法可以允许客户端给服务器提供信息较多。POST方法将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。还以上面的搜索domety为例，如果使用POST方式的话，报文如下：")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('POST /search HTTP/1.1  \nAccept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/vnd.ms-powerpoint, \napplication/msword, application/x-silverlight, application/x-shockwave-flash, */*  \nReferer: <a href="http://www.google.cn/">http://www.google.cn/</a>  \nAccept-Language: zh-cn  \nAccept-Encoding: gzip, deflate  \nUser-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; TheWorld)  \nHost: <a href="http://www.google.cn">www.google.cn</a>  \nConnection: Keep-Alive  \nCookie: PREF=ID=80a06da87be9ae3c:U=f7167333e2c3b714:NW=1:TM=1261551909:LM=1261551917:S=ybYcq2wpfefs4V9g; \nNID=31=ojj8d-IygaEtSxLgaJmqSjVhCspkviJrB6omjamNrSm8lZhKy_yMfO2M4QMRKcH1g0iQv9u-2hfBW7bUFwVh7pGaRUb0RnHcJU37y-\nFxlRugatx63JLv7CWMD6UB_O_r  \n \nhl=zh-CN&source=hp&q=domety\n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("li",[e("p",[this._v("HEAD")]),this._v(" "),e("p",[this._v("HEAD就像GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"响应报文"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#响应报文","aria-hidden":"true"}},[this._v("#")]),this._v(" 响应报文")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("p",[t._v("HTTP响应也由三个部分组成，分别是："),s("strong",[t._v("状态行")]),t._v("、"),s("strong",[t._v("响应头")]),t._v("、"),s("strong",[t._v("空行")]),t._v("、"),s("strong",[t._v("响应正文")]),t._v("。 正如你所见，在响应中唯一真正的区别在于第一行中用状态信息代替了请求信息。状态行（status line）通过提供一个状态码来说明所请求的资源情况。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("HTTP-Version    Status-Code    Reason-Phrase    CRLF\n")])]),this._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[this._v("1")]),e("br")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"http://ofluknnfq.bkt.clouddn.com/blog/180813/E9c1HhEHmi.png?imageslim",alt:"mark"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("状态码")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"http://ofluknnfq.bkt.clouddn.com/blog/180813/caCIjdI86a.png?imageslim",alt:"mark"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("常见的状态码")])])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ul",[s("li",[t._v("200 OK：客户端请求成功。")]),t._v(" "),s("li",[t._v("400 Bad Request：客户端请求有语法错误，不能被服务器所理解。")]),t._v(" "),s("li",[t._v("401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。")]),t._v(" "),s("li",[t._v("403 Forbidden：服务器收到请求，但是拒绝提供服务。")]),t._v(" "),s("li",[t._v("404 Not Found：请求资源不存在，举个例子：输入了错误的URL。")]),t._v(" "),s("li",[t._v("500 Internal Server Error：服务器发生不可预期的错误。")]),t._v(" "),s("li",[t._v("503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，举个例子：HTTP/1.1 200 OK（CRLF）。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("状态码列表")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"http://ofluknnfq.bkt.clouddn.com/blog/180813/jBKKmAeFi1.png?imageslim",alt:"mark"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"http://ofluknnfq.bkt.clouddn.com/blog/180813/7A3Bk2cmjB.png?imageslim",alt:"mark"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"http://ofluknnfq.bkt.clouddn.com/blog/180813/j7a8HALDmC.png?imageslim",alt:"mark"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"http://ofluknnfq.bkt.clouddn.com/blog/180813/e1m8BJDB3g.png?imageslim",alt:"mark"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("HTTP响应头")])])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ul",[s("li",[t._v("Access-Control-Allow-Headers: 服务器端允许的请求Headers")]),t._v(" "),s("li",[t._v("Access-Control-Allow-Methods: 服务器端允许的请求方法")]),t._v(" "),s("li",[t._v("Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）")]),t._v(" "),s("li",[t._v("Content-Type：服务端返回的实体内容的类型")]),t._v(" "),s("li",[t._v("Date：数据从服务器发送的时间")]),t._v(" "),s("li",[t._v("Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档")]),t._v(" "),s("li",[t._v("Last-Modified：请求资源的最后修改时间")]),t._v(" "),s("li",[t._v("Expires：应该在什么时候认为文档已经过期,从而不再缓存它")]),t._v(" "),s("li",[t._v("Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效")]),t._v(" "),s("li",[t._v("ETag：请求变量的实体标签的当前值")]),t._v(" "),s("li",[t._v("Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端")]),t._v(" "),s("li",[t._v("Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）")]),t._v(" "),s("li",[t._v("Server：服务器的一些相关信息")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("譬如，请求头部的"),e("code",[this._v("Accept")]),this._v("要和响应头部的"),e("code",[this._v("Content-Type")]),this._v("匹配，否则会报错")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("譬如，跨域请求时，请求头部的"),e("code",[this._v("Origin")]),this._v("要匹配响应头部的"),e("code",[this._v("Access-Control-Allow-Origin")]),this._v("，否则会报跨域错误")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("p",[t._v("譬如，在使用缓存时，请求头部的"),s("code",[t._v("If-Modified-Since")]),t._v("、"),s("code",[t._v("If-None-Match")]),t._v("分别和响应头部的"),s("code",[t._v("Last-Modified")]),t._v("、"),s("code",[t._v("ETag")]),t._v("对应")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"http-1-1"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1","aria-hidden":"true"}},[this._v("#")]),this._v(" HTTP 1.1")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ol",[s("li",[s("p",[s("strong",[t._v("缓存处理")]),t._v("：在HTTP 1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("长连接")]),t._v(" ：HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。")]),t._v(" "),s("blockquote",[s("p",[t._v("HTTP Pipelining是这样一种技术：在等待上一个请求响应的同时，发送下一个请求。(译者注：作者这个解释并不完全正确，HTTP Pipelining其实是把多个HTTP请求放到一个TCP连接中一一发送，而在发送过程中不需要等待服务器对前一个请求的响应；"),s("strong",[t._v("只不过，客户端还是要按照发送请求的顺序来接收响应")]),t._v("。)但就像在超市收银台或者银行柜台排队时一样，你并不知道前面的顾客是干脆利索的还是会跟收银员/柜员磨蹭到世界末日（译者注：不管怎么说，服务器（即收银员/柜员）是要按照顺序处理请求的，如果前一个请求非常耗时（顾客磨蹭），那么后续请求都会受到影响），"),s("strong",[t._v("这就是所谓的线头阻塞（Head of line blocking）")]),t._v("。")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"http-2-0"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-2-0","aria-hidden":"true"}},[this._v("#")]),this._v(" HTTP 2.0")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"http://ofluknnfq.bkt.clouddn.com/blog/180813/4KB54j28Bl.png?imageslim",alt:"mark"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("HTTP2.0和HTTP1.X相比的新特性")])])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ul",[s("li",[s("p",[s("strong",[t._v("新的二进制格式")]),t._v("（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。")]),t._v(" "),s("p",[s("img",{attrs:{src:"http://ofluknnfq.bkt.clouddn.com/blog/180813/hH5JLllbhe.png?imageslim",alt:"mark"}})])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("多路复用")]),t._v("（MultiPlexing）")]),t._v(" "),s("p",[t._v("在 HTTP 2.0 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。")]),t._v(" "),s("p",[t._v("帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。")]),t._v(" "),s("p",[t._v("多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。")]),t._v(" "),s("p",[s("img",{attrs:{src:"http://ofluknnfq.bkt.clouddn.com/blog/180813/iEgeEffbeB.png?imageslim",alt:"mark"}})])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("Header压缩")])]),t._v(" "),s("p",[t._v("在 HTTP 1.X 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。")]),t._v(" "),s("p",[t._v("在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；")]),this._v(" "),e("li",[this._v("HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；")]),this._v(" "),e("li",[this._v("HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"tls"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tls","aria-hidden":"true"}},[this._v("#")]),this._v(" "),e("strong",[this._v("TLS")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("对称加密")]),this._v("：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("非对称加密")]),this._v("：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("TLS 握手过程如下图：")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"http://ofluknnfq.bkt.clouddn.com/blog/180813/AF3DBK44FF.png?imageslim",alt:"mark"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("客户端发送一个随机值，需要的协议和加密方式")]),this._v(" "),e("li",[this._v("服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）")]),this._v(" "),e("li",[this._v("客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书")]),this._v(" "),e("li",[this._v("服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("通过以上步骤可知，在 TLS 握手阶段，两端使用非对称加密的方式来通信，"),e("u",[this._v("但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"tcp和udp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp和udp","aria-hidden":"true"}},[this._v("#")]),this._v(" TCP和UDP")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"运输层与网络层的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#运输层与网络层的关系","aria-hidden":"true"}},[this._v("#")]),this._v(" 运输层与网络层的关系")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在协议栈中，运输层刚好位于网络层之上。网络层提供了"),e("strong",[this._v("主机之间")]),this._v("的逻辑通信，而运输层为运行在不同主机上的"),e("strong",[this._v("进程之间")]),this._v("提供了逻辑通信。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"多路复用和多路分解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多路复用和多路分解","aria-hidden":"true"}},[this._v("#")]),this._v(" 多路复用和多路分解")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("一个进程（作为网络应用的一部分）有一个或多个套接字（socket），它相当于从网络向进程传递数据和从进程向网络传递数据的门户。因此，在"),e("strong",[this._v("接受主机中的运输层实际上并没有直接将数据交付给进程，而是将数据交给了一个中间的套接字")]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("将运输层报文段报文段中的数据交付到正确的套接字（对应的端口号）的工作称为"),e("strong",[this._v("多路分解")]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在以后用于分解）从而生成报文段，然后将报文段传递到网络层，所有这些工作称为"),e("strong",[this._v("多路复用")]),this._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"udp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#udp","aria-hidden":"true"}},[this._v("#")]),this._v(" UDP")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#特点","aria-hidden":"true"}},[this._v("#")]),this._v(" 特点")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("UDP为调用它的应用程序提供了一种"),e("strong",[this._v("不可靠")]),this._v("，"),e("strong",[this._v("无连接")]),this._v("的服务。进程到进程的数据交付和差错检查是两种最低限度的运输层服务，也是UDP所能提供的仅有的两种服务。也就是说，在两个进程通信前没有握手过程，UDP并不保证该报文将到达接受进程，不仅如此，到达接受进程的报文也可能是乱序到达的。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"报文段结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#报文段结构","aria-hidden":"true"}},[this._v("#")]),this._v(" 报文段结构")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"http://ofluknnfq.bkt.clouddn.com/blog/180815/k6CFCA4KhH.png?imageslim",alt:"mark"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("两个十六位的端口号，分别为源端口（可选字段）和目标端口")]),this._v(" "),e("li",[this._v("整个数据报文的长度")]),this._v(" "),e("li",[this._v("整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"为什么dns基于udp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么dns基于udp","aria-hidden":"true"}},[this._v("#")]),this._v(" 为什么DNS基于UDP")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"面向连接服务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#面向连接服务","aria-hidden":"true"}},[this._v("#")]),this._v(" 面向连接服务")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"可靠的数据传送服务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可靠的数据传送服务","aria-hidden":"true"}},[this._v("#")]),this._v(" 可靠的数据传送服务")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"拥塞控制机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#拥塞控制机制","aria-hidden":"true"}},[this._v("#")]),this._v(" 拥塞控制机制")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"头部"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#头部","aria-hidden":"true"}},[this._v("#")]),this._v(" 头部")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"http://ofluknnfq.bkt.clouddn.com/blog/180815/abIg2lfk56.png?imageslim",alt:"mark"}})])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ul",[s("li",[t._v("Sequence number，这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文")]),t._v(" "),s("li",[t._v("Acknowledgement Number，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到，不过，只有当标志位中的ACK标志（下面介绍）为1时该确认序列号的字段才有效。")]),t._v(" "),s("li",[t._v("Window Size，窗口大小，表示还能接收多少字节的数据，用于流量控制")]),t._v(" "),s("li",[t._v("标识符\n"),s("ul",[s("li",[t._v("URG=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。")]),t._v(" "),s("li",[t._v("ACK=1：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为1。")]),t._v(" "),s("li",[t._v("PSH=1：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。")]),t._v(" "),s("li",[t._v("RST=1：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。")]),t._v(" "),s("li",[t._v("SYN=1：表示同步序号，用来建立连接 ，当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。")]),t._v(" "),s("li",[t._v("FIN=1：该字段为一表示此报文段是一个释放连接的请求报文。")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"三次握手与四次挥手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三次握手与四次挥手","aria-hidden":"true"}},[this._v("#")]),this._v(" 三次握手与四次挥手")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"http://ofluknnfq.bkt.clouddn.com/blog/180815/Fbi5J7egkB.png?imageslim",alt:"mark"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("三次握手：")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；")]),this._v(" "),e("li",[this._v("第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；")]),this._v(" "),e("li",[this._v("第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。\n完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("四次分手：")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；")]),this._v(" "),e("li",[this._v("第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；")]),this._v(" "),e("li",[this._v("第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；")]),this._v(" "),e("li",[this._v("第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("为什么要三次握手？")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"http://ofluknnfq.bkt.clouddn.com/blog/180815/LLLJefdL3d.png?imageslim",alt:"mark"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("为什么要四次分手？")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"websocket"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#websocket","aria-hidden":"true"}},[this._v("#")]),this._v(" WebSocket")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"websocket是什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#websocket是什么？","aria-hidden":"true"}},[this._v("#")]),this._v(" Websocket是什么？")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"为什么需要-websocket-？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要-websocket-？","aria-hidden":"true"}},[this._v("#")]),this._v(" 为什么需要 WebSocket ？")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("了解计算机网络协议的人，应该都知道：HTTP 协议是一种无状态的、无连接的、"),e("strong",[this._v("单向")]),this._v("的应用层协议。它采用了请求/响应模型。通信请求只能由客户端发起，服务端对请求做出应答处理。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"http://ofluknnfq.bkt.clouddn.com/blog/180815/ELhE28GDiK.png?imageslim",alt:"mark"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:"http://ofluknnfq.bkt.clouddn.com/blog/180815/c86lgIcHgd.png?imageslim",alt:"mark"}})])}],!1,null,null,null);e.default=i.exports}}]);