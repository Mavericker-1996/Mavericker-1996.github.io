(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{210:function(t,e,a){"use strict";a.r(e);var v=a(0),_=Object(v.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"react出现的历史背景和特性介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react出现的历史背景和特性介绍","aria-hidden":"true"}},[t._v("#")]),t._v(" React出现的历史背景和特性介绍")]),t._v(" "),a("ul",[a("li",[t._v("课程地址：https://time.geekbang.org/course/detail/100-9437")]),t._v(" "),a("li",[t._v("Demo：https://6n20nrzlxz.codesandbox.io/")]),t._v(" "),a("li",[t._v("源代码：https://codesandbox.io/s/6n20nrzlxz")]),t._v(" "),a("li",[t._v("Github：https://github.com/supnate/react-geek-time")])]),t._v(" "),a("h2",{attrs:{id:"出现背景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#出现背景","aria-hidden":"true"}},[t._v("#")]),t._v(" 出现背景")]),t._v(" "),a("p",[t._v("FaceBook首页消息显示经常出现bug。")]),t._v(" "),a("h2",{attrs:{id:"问题出现的根源"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题出现的根源","aria-hidden":"true"}},[t._v("#")]),t._v(" 问题出现的根源")]),t._v(" "),a("ol",[a("li",[t._v("传统UI操作关注太多细节")]),t._v(" "),a("li",[t._v("应用程序状态分散在各处，难以追踪和维护")])]),t._v(" "),a("h2",{attrs:{id:"提出新的思想"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#提出新的思想","aria-hidden":"true"}},[t._v("#")]),t._v(" 提出新的思想")]),t._v(" "),a("p",[t._v("为此React提出了一个新的思想，即"),a("strong",[t._v("始终整体“刷新”页面")])]),t._v(" "),a("p",[a("strong",[t._v("当发生前后状态变化时，React会自动更新UI")]),t._v("，让我们从复杂的UI操作中解放出来，使我们只需关于状态以及最终UI长什么样。")]),t._v(" "),a("h2",{attrs:{id:"react特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react特性","aria-hidden":"true"}},[t._v("#")]),t._v(" React特性")]),t._v(" "),a("ul",[a("li",[t._v("1个新概念：组件，用组件的方式来描述你的UI")]),t._v(" "),a("li",[t._v("只有4个必须API")]),t._v(" "),a("li",[t._v("单向数据流")]),t._v(" "),a("li",[t._v("完善的错误提示")])]),t._v(" "),a("h2",{attrs:{id:"数据模型解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据模型解决方案","aria-hidden":"true"}},[t._v("#")]),t._v(" 数据模型解决方案")]),t._v(" "),a("p",[t._v("传统MVC在程序复杂之后很难追踪错误，很难确定是Model出现的错误还是View出现的错误。")]),t._v(" "),a("p",[t._v("首先，Flux架构将一个应用分成四个部分：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("View")]),t._v("： 视图层（绑定到Store上的）")]),t._v(" "),a("li",[a("strong",[t._v("Action")]),t._v("（动作）：视图层发出的消息（比如mouseClick）")]),t._v(" "),a("li",[a("strong",[t._v("Dispatcher")]),t._v("（派发器）：用来接收Actions、执行回调函数")]),t._v(" "),a("li",[a("strong",[t._v("Store")]),t._v("（数据层）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面")])]),t._v(" "),a("p",[t._v("Flux的最大特点，就是数据的“单向流动”。")]),t._v(" "),a("ol",[a("li",[t._v("用户访问 View")]),t._v(" "),a("li",[t._v("View 发出用户的 Action")]),t._v(" "),a("li",[t._v("Dispatcher 收到 Action，要求 Store 进行相应的更新")]),t._v(" "),a("li",[t._v('Store 更新后，发出一个"change"事件')]),t._v(" "),a("li",[t._v('View 收到"change"事件后，更新页面')])]),t._v(" "),a("p",[t._v('上面过程中，数据总是"单向流动"，任何相邻的部分都不会发生数据的"双向流动"。这保证了流程的清晰。')]),t._v(" "),a("h2",{attrs:{id:"单向数据流和双向绑定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单向数据流和双向绑定","aria-hidden":"true"}},[t._v("#")]),t._v(" 单向数据流和双向绑定")]),t._v(" "),a("p",[t._v("单向数据流并非‘单向绑定’，甚至单向数据流与绑定没有‘任何关系’。对于React来说，单向数据流（从上到下）与单一数据源这两个原则，限定了React中要想在一个组件中更新另一个组件的状态（类似于Vue的平行组件传参，或者是子组件向父组件传递参数），需要进行状态提升。即将状态提升到他们最近的祖先组件中。子组件中Change了状态，触发父组件状态的变更，父组件状态的变更，影响到了另一个组件的显示（因为传递给另一个组件的状态变化了，这一点与Vue子组件的$emit()方法很相似）。")]),t._v(" "),a("p",[t._v("Vue也是单向数据流(https://cn.vuejs.org/v2/guide/components-props.html)，只不过能实现双向绑定。")]),t._v(" "),a("p",[t._v("单向数据流中的‘单向’是指"),a("strong",[t._v("数据从父组件到子组件这个流向叫单向")]),t._v("。")])])}],!1,null,null,null);e.default=_.exports}}]);